{
  "ver": "0.1",
  "info": {
    "id": "wc33WX",
    "date": "1747616947",
    "viewed": 3,
    "name": "Random Beat every min - 87 years",
    "username": "jakel101",
    "description": "Discussed this idea on Discord the other night, decided to sit down and implement it. Needs better instruments still!\ncan get out of sync after ~1 min, so just reload/recompile and you get something new.",
    "likes": 1,
    "published": 3,
    "flags": 8,
    "usePreview": 0,
    "tags": [
      "random",
      "audio",
      "drums"
    ],
    "hasliked": 0,
    "retrieved": "2025-05-19T01:18:02.782621+00:00"
  },
  "renderpass": [
    {
      "inputs": [],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// Apache 2.0 no patents =_=\n\n/*\n* \n* Image pass holds the visualization, it's might get out of sync with the music for now :/\n* Common pass holds the generation logic\n* Sound pass plays the instruments for 3 minutes.\n* recompile to get new patterns!\n* this should only repeat every ~ 87 years so enjoy some unique patterns!\n*/\n\n# define LINE 0.005\n// TODO: better pixel width\n\n// informed by: https://youtu.be/PMltMdi1Wzg\nfloat sdLineSegment(vec2 p, vec2 a, vec2 b) {\n    // pos, start, end;\n    float d;    \n    // how far along we are between the points.    \n    float h = clamp(dot(p-a, b-a)/(length(b-a)*length(b-a)), 0.0, 1.0);\n    // point along the line between the two points\n    vec2 q = mix(a, b, h);    \n    //d = min(length(p-a),length(p-b)); // this actually doesn't matter anymore\n    d = length(p-q); // debug, show point in between...\n    return d;\n}\n\n// axis aligned box with center offset\nfloat dBox(vec2 p, vec2 c, float h, float w){\n    vec2 s = (p-c); // shift the center\n    \n    float d = length(max(abs(s) - vec2(h/2.0,w/2.0), 0.0));\n    \n    return d;\n}\n\n\n// helper functio to draw the blank lines/their mask\nfloat blank(vec2 p) {\n    // from, x:-0.85 to 0.85 (so 16 notes fit in nicely)\n    // lines at y: -0.2, 0.1, 0.0, 0.1, 0.2\n    // big lines at either end\n    float mask = 0.0;    \n    float width = 0.85;\n    float vert_space = 0.1;\n    \n    // five horizontal lines\n    int i;    \n    for (i=-2; i<=2; i++){\n        float height = vert_space*float(i);\n        float l = sdLineSegment(p, vec2(width, height), vec2(-width, height));\n        mask += smoothstep(LINE, 0.0, l);\n    }\n    \n    // maybe use rectanle instead?\n    float left = dBox(p, vec2(-width, 0.0), 0.01, vert_space*4.0);\n    float right = dBox(p, vec2(width, 0.0), 0.01, vert_space*4.0);\n    mask += smoothstep(LINE, 0.0, left);\n    mask += smoothstep(LINE, 0.0, right);\n    \n    return mask; //step(0.5, mask); // step to make it more solid (really whacky)\n}\n\n\n// helper function to the top of the beamed notes\nfloat beams(vec2 p) {\n    // should be double beamed 1/16th?\n    // from like -0.8 to -0.5; -0.4 to 0.0; ...?\n    float mask;\n    float height = 0.4;\n    int i;\n    for (i=0; i<4; i++){\n        float start = -0.71 + float(i)*0.4;\n        float l1 = dBox(p, vec2(start + 0.15, height + 0.05), 0.3, 0.03); \n        float l2 = dBox(p, vec2(start + 0.15, height), 0.3, 0.015); \n        mask += smoothstep(LINE, 0.0, l1);\n        mask += smoothstep(LINE, 0.0, l2);\n    }    \n    \n    return mask;    \n}\n\n// draw notes (masks)\nfloat note(vec2 p, int time, uint type) {\n    // type: 0 - kick, 1 - snare, 2 - hi hat\n    // kick between 1 and 2 (height -0.3)\n    // snare is between 3 and 4 (height 0.1)\n    // hi hat is a ghost note (X) above 5 (height 0.5)\n    // time is 0..16 at 0.1 intervals        \n    float mask;\n    float size = 0.04;\n    float x = -0.75 + float(time)*0.1;\n    float y = -0.15 + float(type)*0.2; // height\n    \n    \n    float dist_note;\n    float stem_bot = y;\n    if (type > 1u){\n        // hh ghostnote!\n        float l1 = sdLineSegment(p, vec2(x+size,y+size), vec2(x-size,y-size));        \n        float l2 = sdLineSegment(p, vec2(x+size,y-size), vec2(x-size,y+size));       \n        dist_note = min(l1, l2);\n        stem_bot += size;\n    } \n    else {\n        // TODO: little twist!\n        dist_note = length(p-vec2(x,y)) - size;\n    }\n    float stem_dist = sdLineSegment(p, vec2(x+size, stem_bot), vec2(x+size, 0.45));\n    \n    mask += smoothstep(LINE, 0.0, min(dist_note, stem_dist));\n    //mask += smoothstep(LINE, 0.0, stem_dist);\n    return mask;\n    \n}\n\n// mask again...\nfloat notes(vec2 p, uint beat){\n    int i;\n    float mask;\n    for (i=0; i<16; i++){\n        uint type = beat & 3u; // select lowest two bits\n        type = min(type, 2u); // this shouldn't exist anyway.\n        beat = beat >> 2; // shift to bits out for next step\n        float note_mask = note(p, i, type);\n        mask += note_mask;\n    }\n    return mask;\n}\n\n\n// vizualize the BPM?\nfloat indicator(vec2 p){\n    float mask;\n    float beat_time = mod(iTime, (60.0*4.0/BPM))/(60.0*4.0/BPM); // for test\n    \n    vec2 pos = vec2(-0.75 + beat_time*(2.0*0.75), -0.5);\n    \n    float d = length(p-pos);\n    mask = smoothstep(0.1, 0.0, d);\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint beat = beat_hash();\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv -= vec2(0.5);\n    uv *= 2.0;\n    \n    float line_dist = sdLineSegment(uv, vec2(0.85, 0.3), vec2(-0.85, 0.3));\n\n    vec3 col = vec3(0.95, 0.98, 0.90);\n    \n    float bg_lines = blank(uv);\n    float tops = beams(uv);\n    float notes_mask = notes(uv, beat);\n    float indicator_mask = indicator(uv);\n    col = mix(col, vec3(0.01), bg_lines);\n    col = mix(col, vec3(0.02), tops);\n    col = mix(col, vec3(0.03), notes_mask);    \n    col = mix(col, vec3(0.85, 0.23, 0.02), indicator_mask);\n    fragColor = vec4(col,1.0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    },
    {
      "inputs": [],
      "outputs": [],
      "code": "# define LIFE 6\n// linetime of 2^n seconds per beat. Meant to be 6, but 0 or 1 can be used for testing\n\n# define BPM 75.0\n// change, recompile, play and then rewind!\n\n\n// TODO: does this hash every repeat? I am not sure\n// via https://www.shadertoy.com/view/XlGcRh\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\n//TODO this is not at all accurate, but good enough for the demo\nuint unixTime(){\n    // deconstruct iDate back into a 32 bit unix timestamp:\n    // iDate.x = years\n    // iDate.y = months\n    // iDate.z = days\n    // iDate.w = seconds (including fractionals)\n    // TODO month/day is off by one?\n    uint time;\n    \n    uvec4 date = uvec4(iDate);\n    date.x -= 1970u; // offset since Unix epoch!\n    \n    // lazy addition for now to get a value.\n    // TODO: improve values.\n    time += uint(365.24 * float(date.x )) * 24u * 60u * 60u;\n    time += 30u*date.y * 24u * 60u * 60u;\n    time += date.z * 24u * 60u * 60u;\n    time += date.w;\n    \n    // On the Image pass we subtract the current runtime to get the time during compilation\n    // this is meant to match the Sound pass compilation varaint in the future.\n    //time -= uint(iTime); // can be out of sync -.-\n    return time;\n\n}\n\n// 32 bit value interpreted at trinary by reading 2 bits with max(2)\n// this should hash\nuint beat_hash(){\n    uint beat;\n    \n    // placeholder\n    beat = unixTime();\n    // to cause variations about every ~1 minute, we ignore the lowest 6 bits\n    // our target space is 3^16 which needs less than 26 bits.\n    uint seed = beat >> LIFE; // 6 bits to only change every 64 seconds, reduced for testing\n    uint max_val = 43046720u; //3^16 -1\n    seed = pcg(seed);\n    //seed = seed%max_val; // so it rolls over?\n    \n    \n    \n    // convert to (binary-encoded) trineary representation:        \n    int i;\n    uint val = seed; // this is too imprecise? we lose precision\n    for (i=0; i<16; i++){\n        uint tri = val%3u;\n        val = val/3u; // move to quotient for the next part\n        // fill two bits at a time\n        beat = beat << 2u;\n        beat += uint(tri);//uint(tri);  \n    }    \n    return beat;\n}\n",
      "name": "Common",
      "description": "",
      "type": "common"
    },
    {
      "inputs": [],
      "outputs": [],
      "code": "# define TAU 6.2831\n\n/* \n* I welcome any improvements to the instruments:\n* the envelope is awfully cutoff\n* better drum machines exist on Shadertoy alreay\n* there is a progressively growing undertone, maybe it can be corrected\n*/\n\n//  TODO easier attach/pluck\nfloat envelope(float t, float target_t) {\n    // this is a bad idea to cutoff the attack!!\n    if (t < target_t + 0.025) return 0.0;\n    \n    // shifts the wave to the target place\n    float t2 = t-target_t+0.05;\n    \n    return max(0.0, 5.0*t2*exp(-20.0*(t2-0.09)));\n}\n\n// TODO: better instruments\nfloat kick(float t, float env) {    \n    return sin(TAU*180.0*t)*env;\n}\n\nfloat snare(float t, float env) {\n    return sin(TAU*341.0*t)*env;\n}\n\nfloat hihat(float t, float env) {\n    return sin(TAU*830.0*t)*env;\n}\n\n// returns the instrument[0,1,2] type per measure\nint player(int measure, uint beat){\n    // read exactly the two bits in the 32-bit uint for this measure\n    uint type = (beat >> 2*measure) & 3u;\n    return int(type);\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    // there probably needs to be an additional time so the cutoff isn't this random!\n    float beat_time = mod(time, (60.0*4.0/BPM))/(60.0*4.0/BPM);\n    uint beat = beat_hash();\n    \n    float signal;\n    \n    int i;\n    for (i=0; i<16; i++){\n        int type = player(i, beat);\n        float env = envelope(beat_time, float(i)/16.0);\n        float sound;\n        if (type == 0) {\n        // TODO: we could add all envs first and then call the instrument once instead\n            sound = kick(time, env);\n        }\n        else if (type == 1) {\n            sound = snare(time, env);\n        }\n        else if (type == 2) {\n            sound = hihat(time, env);\n        }        \n        signal += sound; \n    }\n    \n    // lots of fun with streo left over here.\n    return vec2(signal);\n}",
      "name": "Sound",
      "description": "",
      "type": "sound"
    }
  ]
}