{
  "ver": "0.1",
  "info": {
    "id": "wc33WX",
    "date": "1747616947",
    "viewed": 199,
    "name": "Random Beat every min - 87 years",
    "username": "jakel101",
    "description": "Discussed this idea on Discord the other night, decided to sit down and implement it. Needs better instruments still!\ncan get out of sync after ~1 min, so just reload/recompile and you get something new.\n\n(instrument improvements in progress)",
    "likes": 9,
    "published": 3,
    "flags": 8,
    "usePreview": 0,
    "tags": [
      "random",
      "audio",
      "drums"
    ],
    "hasliked": 0,
    "retrieved": "2025-07-14T22:44:35.462180+00:00"
  },
  "renderpass": [
    {
      "inputs": [],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// Apache 2.0 no patents =_=\n// attributions welcome!\n// would love to hear abour your interpretation for this!\n\n\n/*\n* \n* Image pass holds the visualization, it's might get out of sync with the music for now :/\n* Common pass holds the generation logic\n* Sound pass plays the instruments for 3 minutes.\n* recompile to get new patterns!\n* this should only repeat every ~ 87 years so enjoy some unique patterns!\n*/\n\n# define LINE 0.005\n// TODO: better pixel width\n\n// informed by: https://youtu.be/PMltMdi1Wzg\nfloat sdLineSegment(vec2 p, vec2 a, vec2 b) {\n    // pos, start, end;\n    float d;    \n    // how far along we are between the points.    \n    float h = clamp(dot(p-a, b-a)/(length(b-a)*length(b-a)), 0.0, 1.0);\n    // point along the line between the two points\n    vec2 q = mix(a, b, h);    \n    //d = min(length(p-a),length(p-b)); // this actually doesn't matter anymore\n    d = length(p-q); // debug, show point in between...\n    return d;\n}\n\n// axis aligned box with center offset\nfloat dBox(vec2 p, vec2 c, float h, float w){\n    vec2 s = (p-c); // shift the center\n    \n    float d = length(max(abs(s) - vec2(h/2.0,w/2.0), 0.0));\n    \n    return d;\n}\n\n\n// helper functio to draw the blank lines/their mask\nfloat blank(vec2 p) {\n    // from, x:-0.85 to 0.85 (so 16 notes fit in nicely)\n    // lines at y: -0.2, 0.1, 0.0, 0.1, 0.2\n    // big lines at either end\n    float mask = 0.0;    \n    float width = 0.85;\n    float vert_space = 0.1;\n    \n    // five horizontal lines\n    int i;    \n    for (i=-2; i<=2; i++){\n        float height = vert_space*float(i);\n        float l = sdLineSegment(p, vec2(width, height), vec2(-width, height));\n        mask += smoothstep(LINE, 0.0, l);\n    }\n    \n    // maybe use rectanle instead?\n    float left = dBox(p, vec2(-width, 0.0), 0.01, vert_space*4.0);\n    float right = dBox(p, vec2(width, 0.0), 0.01, vert_space*4.0);\n    mask += smoothstep(LINE, 0.0, left);\n    mask += smoothstep(LINE, 0.0, right);\n    \n    return mask; //step(0.5, mask); // step to make it more solid (really whacky)\n}\n\n\n// helper function to the top of the beamed notes\nfloat beams(vec2 p) {\n    // should be double beamed 1/16th?\n    // from like -0.8 to -0.5; -0.4 to 0.0; ...?\n    float mask;\n    float height = 0.4;\n    int i;\n    for (i=0; i<4; i++){\n        float start = -0.71 + float(i)*0.4;\n        float l1 = dBox(p, vec2(start + 0.15, height + 0.05), 0.3, 0.03); \n        float l2 = dBox(p, vec2(start + 0.15, height), 0.3, 0.015); \n        mask += smoothstep(LINE, 0.0, l1);\n        mask += smoothstep(LINE, 0.0, l2);\n    }    \n    \n    return mask;    \n}\n\n// draw notes (masks)\nfloat note(vec2 p, int time, uint type) {\n    // type: 0 - kick, 1 - snare, 2 - hi hat\n    // kick between 1 and 2 (height -0.3)\n    // snare is between 3 and 4 (height 0.1)\n    // hi hat is a ghost note (X) above 5 (height 0.5)\n    // time is 0..16 at 0.1 intervals        \n    float mask;\n    float size = 0.04;\n    float x = -0.75 + float(time)*0.1;\n    float y = -0.15 + float(type)*0.2; // height\n    \n    \n    float dist_note;\n    float stem_bot = y;\n    if (type > 1u){\n        // hh ghostnote!\n        float l1 = sdLineSegment(p, vec2(x+size,y+size), vec2(x-size,y-size));        \n        float l2 = sdLineSegment(p, vec2(x+size,y-size), vec2(x-size,y+size));       \n        dist_note = min(l1, l2);\n        stem_bot += size;\n    } \n    else {\n        // TODO: little twist!\n        dist_note = length(p-vec2(x,y)) - size;\n    }\n    float stem_dist = sdLineSegment(p, vec2(x+size, stem_bot), vec2(x+size, 0.45));\n    \n    mask += smoothstep(LINE, 0.0, min(dist_note, stem_dist));\n    //mask += smoothstep(LINE, 0.0, stem_dist);\n    return mask;\n    \n}\n\n// mask again...\nfloat notes(vec2 p, uint beat){\n    int i;\n    float mask;\n    for (i=0; i<16; i++){\n        uint type = beat & 3u; // select lowest two bits\n        type = min(type, 2u); // this shouldn't exist anyway.\n        beat = beat >> 2; // shift to bits out for next step\n        float note_mask = note(p, i, type);\n        mask += note_mask;\n    }\n    return mask;\n}\n\n\n// vizualize the BPM?\nfloat indicator(vec2 p){\n    float mask;\n    float beat_time = mod(iTime, (60.0*4.0/BPM))/(60.0*4.0/BPM); // for test\n    \n    vec2 pos = vec2(-0.75 + beat_time*(2.0*0.75), -0.5);\n    \n    float d = length(p-pos);\n    mask = smoothstep(0.1, 0.0, d);\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint beat = beat_hash();\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv -= vec2(0.5);\n    uv *= 2.0;\n    \n    float line_dist = sdLineSegment(uv, vec2(0.85, 0.3), vec2(-0.85, 0.3));\n\n    //TODO: more interesting background texture, maybe paper\n    vec3 col = vec3(0.95, 0.98, 0.90);\n    \n    float bg_lines = blank(uv);\n    float tops = beams(uv);\n    float notes_mask = notes(uv, beat);\n    float indicator_mask = indicator(uv);\n    col = mix(col, vec3(0.01), bg_lines);\n    col = mix(col, vec3(0.02), tops);\n    col = mix(col, vec3(0.03), notes_mask);    \n    col = mix(col, vec3(0.85, 0.23, 0.02), indicator_mask);\n    fragColor = vec4(col,1.0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    },
    {
      "inputs": [],
      "outputs": [],
      "code": "# define LIFE 6\n// linetime of 2^n seconds per beat. Meant to be 6, but 0 or 1 can be used for testing\n\n# define BPM 85.0\n// change, recompile, play and then rewind!\n\n\n// TODO: does this hash every repeat? I am not sure\n// via https://www.shadertoy.com/view/XlGcRh\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\n//TODO this is not at all accurate, but good enough for the demo\nuint unixTime(){\n    // deconstruct iDate back into a 32 bit unix timestamp:\n    // iDate.x = years\n    // iDate.y = months\n    // iDate.z = days\n    // iDate.w = seconds (including fractionals)\n    // TODO month/day is off by one?\n    uint time;\n    \n    uvec4 date = uvec4(iDate);\n    date.x -= 1970u; // offset since Unix epoch!\n    \n    // lazy addition for now to get a value.\n    // TODO: improve values.\n    time += uint(365.24 * float(date.x )) * 24u * 60u * 60u;\n    time += 30u*date.y * 24u * 60u * 60u;\n    time += date.z * 24u * 60u * 60u;\n    time += date.w;\n    \n    // On the Image pass we subtract the current runtime to get the time during compilation\n    // this is meant to match the Sound pass compilation varaint in the future.\n    //time -= uint(iTime); // can be out of sync -.-\n    return time;\n\n}\n\n// 32 bit value interpreted at trinary by reading 2 bits with max(2)\n// this should hash\nuint beat_hash(){\n    uint beat;\n    \n    // placeholder\n    beat = unixTime();\n    // to cause variations about every ~1 minute, we ignore the lowest 6 bits\n    // our target space is 3^16 which needs less than 26 bits.\n    uint seed = beat >> LIFE; // 6 bits to only change every 64 seconds, reduced for testing\n    uint max_val = 43046720u; //3^16 -1\n    seed = pcg(seed);\n    //seed = seed%max_val; // so it rolls over?\n    \n    \n    \n    // convert to (binary-encoded) trineary representation:        \n    int i;\n    uint val = seed; // this is too imprecise? we lose precision\n    for (i=0; i<16; i++){\n        uint tri = val%3u;\n        val = val/3u; // move to quotient for the next part\n        // fill two bits at a time\n        beat = beat << 2u;\n        beat += uint(tri);//uint(tri);  \n    }    \n    return beat;\n}\n",
      "name": "Common",
      "description": "",
      "type": "common"
    },
    {
      "inputs": [],
      "outputs": [],
      "code": "# define TAU 6.2831\n\n/* \n* I welcome any improvements to the instruments:\n* the envelope is awfully cutoff\n* better drum machines exist on Shadertoy alreay\n* there is a progressively growing undertone, maybe it can be corrected\n*/\n\n// sorta useful as white noise for now\nfloat noise(float t){\n    // really bad idea but will do for now...\n    uint u = floatBitsToUint(t);\n    u = pcg(u);    \n    float n =  uintBitsToFloat(u);\n    n = clamp(n, -1.0, 1.0);\n    return n;\n}\n\n//  TODO easier attach/pluck\nfloat envelope_drum(float t, float target_t) {\n    // this is a bad idea to cutoff the attack!!\n    if (t < target_t + 0.025) return 0.0;\n    \n    // shifts the wave to the target place\n    float t2 = t-target_t+0.05;\n    // avoid the hard cuttoffs!\n    return max(0.0, 5.0*t2*exp(-50.0*(t2-0.095)));\n}\n\n// TODO: better instruments\nfloat kick(float t, float beat_time, float hit_time) {\n    float env = envelope_drum(beat_time, hit_time);\n    env = smoothstep(0.05, 0.95, env);\n    float freq = 1.0-sinh((beat_time-hit_time)*TAU/2.0)*66.0;\n    float tone = sin(TAU*freq);\n    return 1.5*tone*env;\n}\n\nfloat snare(float t, float beat_time, float hit_time) {\n    float env = envelope_drum(beat_time, hit_time);\n    env = smoothstep(0.01, 0.9, env); // cut this off more\n    // TODO: follow the concept: https://youtu.be/hULEn2_4Unw\n    float freq = 1.0-tan((beat_time-hit_time)*TAU/2.0)*221.0;\n    float tone = sin(TAU*freq);\n    float noise = noise(t);\n    return (0.02*noise+tone)*env;\n}\n\nfloat hihat(float t, float beat_time, float hit_time) {\n    // TODO: better hi hat hit \n    float env = envelope_drum(beat_time, hit_time);\n    env = tan(env);\n    // fake gate\n    float gate = smoothstep(0.20,0.80, env);\n    float noise = noise(beat_time+t);\n    noise = clamp(noise, 0.0, 1.0);\n    \n    float tone = sin(TAU * 3420.0 * t);\n    tone *= sin(tone*8.20);\n        \n    \n    float signal = (0.5*tone+noise)*gate*env;\n    \n    return signal;\n}\n\n// returns the instrument[0,1,2] type per measure\nint player(int measure, uint beat){\n    // read exactly the two bits in the 32-bit uint for this measure\n    uint type = (beat >> 2*measure) & 3u;\n    return int(type);\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    // there probably needs to be an additional time so the cutoff isn't this random!\n    float beat_time = mod(time, (60.0*4.0/BPM))/(60.0*4.0/BPM);    \n    // can we avoid the mod and instead do a gate/trigger?\n    \n    uint beat = beat_hash();\n    \n    float signal;\n    \n    int i;\n    for (i=0; i<16; i++){\n        int type = player(i, beat);\n        float hit_time = float(i)/16.0;        \n        float sound;\n        if (type == 0) {\n            sound = kick(time, beat_time, hit_time);\n        }\n        else if (type == 1) {\n            sound = snare(time, beat_time, hit_time);\n        }\n        else if (type == 2) {\n            sound = hihat(time, beat_time, hit_time);\n        }\n        // TODO: proper mixing\n        signal += sound; \n    }\n    \n    // lots of fun with streo left over here.\n    return vec2(signal);\n}",
      "name": "Sound",
      "description": "",
      "type": "sound"
    }
  ]
}