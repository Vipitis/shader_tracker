{
  "ver": "0.1",
  "info": {
    "id": "M3VBWt",
    "date": "1738883384",
    "viewed": 168,
    "name": "orthographic heightmap (WIP)",
    "username": "jakel101",
    "description": "goal is to display some texture as a 3D heighmap. like an array of columns maybe?",
    "likes": 4,
    "published": 3,
    "flags": 0,
    "usePreview": 0,
    "tags": [
      "25d",
      "heightmap",
      "orthographic"
    ],
    "hasliked": 0,
    "retrieved": "2025-06-05T23:49:51.807010+00:00"
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 48,
          "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg",
          "ctype": "texture",
          "channel": 0,
          "sampler": {
            "filter": "mipmap",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// APache 2.0 no patents \\_%_/\n# define PI 3.141592653\n# define HEIGHT_SCALE 0.4\n\n// resolution of the sampled area\n# define CELLS ivec2(iChannelResolution[0].xy)\n\n// unsure yet where to bring this!\n# define SUN normalize(vec3(sin(iDate.w), cos(iTime), 0.25))\n\n\nivec2 worldToCell(vec3 p) {\n    \n    // move world space again\n    p += 1.0;\n    p *= 0.5;\n    ivec2 st = ivec2((p.xy*vec2(CELLS.xy)));\n    // TODO: find an actual solution to the edge cases!\n    st = min(st, CELLS -1);\n    return st;\n}\n\nvec2 cellToWorld(ivec2 current_cell,  vec2 dirs){\n    // gives the rear plane of a cell, based on dirs?\n    // TODO: can we avoid this magic epsilon number?\n    // \n    vec2 p = vec2(current_cell);    \n    p -= min(vec2(0.0),dirs); // the \"step\"?\n    \n    // scale and shift    \n    p /= vec2(CELLS);\n    p *= 2.0;\n    p -= 1.0;\n    //p = min(p, vec2(1.0));\n    return p;\n    \n}\n\nvec3 AABB(vec3 center, vec3 extend, vec3 ro, vec3 rd){        \n    // extend goes both ways! (size)\n    vec3 front = center + sign(-rd)*extend; \n    vec3 rear = center + sign(rd)*extend; \n    \n    //now distance those 6 planes:\n    vec3 front_dist = (front-ro)/rd;\n    vec3 rear_dist = (rear-ro)/rd;\n    \n    // TODO: turn into massive if/else if/else blocks for the direction info?\n    float front_hit = max(max(front_dist.x, front_dist.y), front_dist.z); // front \n    float rear_hit = min(min(rear_dist.x, rear_dist.y), rear_dist.z);\n    vec3 res = vec3(front_hit, rear_hit, 0.0);    \n    if (front_hit > rear_hit){\n        // TODO: encode this information otherwise\n        res.x = -1.0;\n        res.y = -1.0;\n    }\n    // TODO: encode hit side/normal in .z and .w\n    return res;\n}\n\nvec3 pillar_hits(ivec2 cell, float height, vec3 ro, vec3 rd){\n    // returns the front and rear distance\n    // if both values are negative it's a miss\n    // .zw contains information about the entry/exit 0: +x, 1: -x, 2: +y, 3: -y, 4: +z, 5: -z??\n    \n    // let's move the pillar into world space by having it's center + extends    \n    vec3 extend = vec3(1.0/vec2(CELLS), height*0.5);\n    vec3 p = vec3(cell.xy, height*0.5);    \n    p.xy *= extend.xy; \n    p.xy *= 2.0;\n    p.xy -= 1.0 - extend.xy; // not quite the offset?\n    // TODO: redo this math when less asleep...\n    vec3 res = AABB(p, extend, ro, rd);\n    return res;\n}\n\n\nvec4 sampleHeight(ivec2 cell){\n    // to allow for more complex math to determine height\n    // .rgb should just return the texture color or some modification of it\n    //cell.x = (cell.x + iFrame) % int(iChannelResolution[0].x); // fun texture scroll\n    vec4 tex = texelFetch(iChannel0, cell, 0);\n    vec4 res;\n    res.a = (tex.a + tex.r + tex.g)/3.0;\n    res.rgb = tex.rgb; // * res.a // to make it more of a \"height\" map?\n    //res.rgb = vec3(0.5);\n    res.a *= HEIGHT_SCALE;\n    return res;\n}\n\nvec3 sampleGround(vec3 ro, vec3 rd){\n    // for any ray that misses the heightmap\n    float ground_height = 0.0;\n    float ground_dist = (ground_height-ro.z)/rd.z;\n    vec3 ground_hit = ro + rd * ground_dist;\n    \n    vec3 col = vec3(fract(ground_hit.xy), ground_dist);\n    \n    // temporary test\n    vec3 sun_angle = SUN;\n    // simple cast to a plane at x=1 (for now)\n    vec3 sun_dist = (vec3(sign(sun_angle.xy)*-1.0, 1.0)-ground_hit)/sun_angle;\n    float closest = max(sun_dist.x, sun_dist.y);\n    vec3 edge_intersect = ground_hit + sun_angle * closest;\n    float shadow = .8;\n    float edge_height = sampleHeight(worldToCell(edge_intersect)).a;\n    if (edge_intersect.z < edge_height && abs(max(edge_intersect.x, edge_intersect.y)) < 1.0) {\n        shadow = 0.2;\n        //TODO: this needs to go further if above untill we leave the top of the box....\n    }\n    // if this is negative we missed the whole block\n    if (closest < 0.0) shadow = 0.8;\n    \n    \n    col.rgb *= shadow;\n    return col;\n}\n\nvec4 raycast(vec3 ro, vec3 rd){\n    // cast the ray untill there is a hit or we exit the box\n    // \"any hit\" shader?\n    // returns tex + dist\n    \n    vec3 box_hit = AABB(vec3(0.0, 0.0, HEIGHT_SCALE*0.5), vec3(1.0, 1.0, HEIGHT_SCALE*0.5), ro, rd);\n    // miss\n    if ( box_hit.x < 0.0 && box_hit.y < 0.0){\n        // likely sample round here\n        return vec4(sampleGround(ro, rd).rgb, -1.0);\n    }        \n    vec3 entry;\n    entry = ro + (rd*box_hit.x);\n    int i;\n    int max_depth = (CELLS.x + CELLS.y)+2; // could also be min!    \n    for (i = 0; i < max_depth; i++){\n        ivec2 current_cell = worldToCell(entry); // TODO: this one is problematic!\n        vec4 tex = sampleHeight(current_cell);\n        vec3 hit = pillar_hits(current_cell, HEIGHT_SCALE, ro, rd);\n        // miss to the sides -shouldn't happen!?\n        vec3 exit = ro + (rd * hit.y);        \n        if ( hit.x < 0.0 && hit.y < 0.0){\n            //return vec4(tex.a);            \n        }\n        \n        else if (exit.z > tex.a) {\n            // top miss -> continues   (breaks shadows!)         \n        }                \n        else {\n            // must be hit side here!            \n            return vec4(tex.rgb, hit.x);\n        }\n        \n        //return entry.rgbb;\n        exit += rd*0.001; // nudge needed to step into new cell from exit pos!\n        entry = exit;\n    }\n    \n    // defualt \"miss\"?\n    return vec4(sampleGround(ro, rd).rgb, -1.0);\n\n}\n\nfloat shadow(vec3 ro, vec3 rd){\n    // return the amount of shadowed?\n    // we are now marching upwards from some hit\n    // ro is essentially the point we started from\n    // rd is the sun angle\n    \n    vec4 res = raycast(ro, rd);\n    \n    // likely means outside the box/ground!\n    if (res.a < 0.0){\n        return 0.0;\n    }\n    else {\n        return 0.5;\n    }\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv normalized to [-1..1] for height with more width\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mo = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    // for when it's just idling...   \n    float azimuth = iTime*0.15 + mo.x;\n    float altitude = 0.7+cos(iTime*0.4)*0.15;      \n    if (sign(iMouse.z) > 0.0){\n        // orbiting camera setup\n        azimuth = PI*mo.x;\n        altitude = 0.5*PI*clamp(mo.y+1.0, -0.01, 0.99); // maybe just positive?\n    }\n    \n    // make sure you don't look \"below\"\n    altitude = clamp(altitude, HEIGHT_SCALE, PI);\n    \n    vec3 camera_pos = vec3(\n        cos(azimuth)*cos(altitude),\n        sin(azimuth)*cos(altitude),\n        sin(altitude));    \n    // the camera is always looking \"at\" the origin\n    vec3 look_dir = vec3(0.0, 0.0, HEIGHT_SCALE*0.5) - camera_pos;\n    \n    camera_pos += look_dir * -1.0; // moving the camera \"back\" to avoid occlusions?\n    // two vectors orthogonal to this camera direction (tagents?)    \n    //vec3 look_u = camera_pos + vec3(-sin(azimuth), cos(azimuth), 0.0);\n    //vec3 look_v = camera_pos + vec3(sin(altitude)*-cos(azimuth), sin(altitude)*-sin(azimuth), cos(altitude));    \n    \n    // turns out analytically these aren't correct. so using cross instead -.-\n    vec3 look_u = normalize(cross(vec3(0.0, 0.0, -1.0), look_dir));\n    vec3 look_v = normalize(cross(camera_pos, look_u)); // is this faster?\n    // camera plane(origin of each pixel) -> barycentric?\n    \n    // orthographic zoom just makes the sensor smaller\n    float zoom = clamp(1.0 + cos(iTime*0.3), 0.05, 1.5);\n    vec3 camera_plane = camera_pos + (look_u*uv.x)*zoom + (look_v*uv.y)*zoom; // wider fov = larger \"sensor\"    \n        \n    \n    // actual stuff happening:\n    vec4 res = raycast(camera_plane, look_dir);\n    vec3 hit = camera_plane + look_dir*res.a;    \n    float shadow_amt = shadow(hit, SUN);    \n    \n    vec3 col = res.rgb - shadow_amt;\n    \n    \n    \n    fragColor = vec4(vec3(col),1.0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}