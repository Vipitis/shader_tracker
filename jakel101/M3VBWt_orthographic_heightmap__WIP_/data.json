{
  "ver": "0.1",
  "info": {
    "id": "M3VBWt",
    "date": "1738883384",
    "viewed": 157,
    "name": "orthographic heightmap (WIP)",
    "username": "jakel101",
    "description": "goal is to display some texture as a 3D heighmap. like an array of columns maybe?",
    "likes": 4,
    "published": 3,
    "flags": 0,
    "usePreview": 0,
    "tags": [
      "25d",
      "heightmap",
      "orthographic"
    ],
    "hasliked": 0,
    "retrieved": "2025-05-19T01:18:02.782621+00:00"
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 8,
          "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
          "ctype": "texture",
          "channel": 0,
          "sampler": {
            "filter": "mipmap",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// APache 2.0 no patents \\_%_/\n# define PI 3.141592653\n# define HEIGHT_SCALE 0.4\n\nivec2 worldToCell(vec3 p, ivec2 cells) {\n    // from the sampleTexture function above\n    \n    p += 1.0;\n    p *= 0.5;\n    ivec2 st = ivec2((p.xy*vec2(cells.xy)));\n    // TODO: find an actual solution to the edge cases!\n    st = min(st, cells -1);\n    return st;\n}\n\nvec2 cellToWorld(ivec2 current_cell, ivec2 cells, vec2 dirs){\n    // gives the rear plane of a cell, based on dirs?\n    // TODO: can we avoid this magic epsilon number?\n    // \n    vec2 p = vec2(current_cell);    \n    p -= min(vec2(0.0),dirs); // the \"step\"?\n    \n    // scale and shift    \n    p /= vec2(cells);    \n    p *= 2.0;\n    p -= 1.0;\n    //p = min(p, vec2(1.0));\n    return p;\n    \n}\n\nvec4 sampleHeight(ivec2 cell){\n    // to allow for more complex math to determine height\n    // .rgb should just return the texture color or some modification of it\n    //cell.x = (cell.x + iFrame) % int(iChannelResolution[0].x); // fun texture scroll\n    vec4 tex = texelFetch(iChannel0, cell, 0);\n    vec4 res;\n    res.a = (tex.a + tex.r + tex.g)/3.0;\n    res.rgb = tex.rgb; // * res.a // to make it more of a \"height\" map?\n    //res.rgb = vec3(0.5);\n    res.a *= HEIGHT_SCALE; //TODO: global height scale?\n    return res;\n}\n\nvec3 sampleGround(vec3 ro, vec3 rd){\n    // for any ray that misses the heightmap\n    float ground_height = 0.0;\n    float ground_dist = (ground_height-ro.z)/rd.z;\n    vec3 ground_hit = ro + rd * ground_dist;\n    \n    vec3 col = vec3(fract(ground_hit.xy), ground_dist);\n    \n    // temporary test\n    vec3 sun_angle = normalize(vec3(0.8, 0.7, 0.5));\n    // simple cast to a plane at x=1 (for now)\n    vec3 sun_dist = (vec3(sign(sun_angle.xy)*-1.0, 1.0)-ground_hit)/sun_angle;\n    float closest = max(sun_dist.x, sun_dist.y);\n    vec3 edge_intersect = ground_hit + sun_angle * closest;\n    float shadow = .8;\n    float edge_height = sampleHeight(worldToCell(edge_intersect, ivec2(iChannelResolution[0].xy))).a;\n    if (edge_intersect.z < edge_height && abs(max(edge_intersect.x, edge_intersect.y)) < 1.0) {\n        shadow = 0.2;\n    }\n    // if this is negative we missed the whole block\n    if (closest < 0.0) shadow = 0.8;\n    \n    col.rgb *= shadow;\n    return col;\n}\n\nfloat shadow(vec3 ro, vec3 rd, ivec2 cells){\n    // return the amount of shadowed?\n    // we are now marching upwards from some hit\n    // ro is essentially the point we started from\n    // rd is the sun angle        \n    \n    vec2 dirs = sign(rd.xy) * -1.0;\n    if (dirs.x == 0.0 || dirs.y == 0.0) (dirs = vec2(1)); // avoid 0.0\n    \n    vec3 hit = ro;\n    int i;\n    for(i=0; i <(cells.x+cells.y)*2; i++){\n        if (min(hit.x, hit.y) < -1.0) return float(0.0);\n        if (max(hit.x, hit.y) > 1.0) return float(0.0);\n        ivec2 current_cell = worldToCell(hit, cells);          \n        \n        \n        vec3 rear_walls = vec3(cellToWorld(current_cell, cells, dirs), 1.0); \n        \n        vec4 tex = sampleHeight(current_cell);\n        \n        vec3 far_dist = (rear_walls-hit)/rd;\n        \n        \n        //TODO: the side hit on the first seems to be wrong height...\n        // side hit -> full shadow\n        // fake penumbra: scaled by distance\n        if (tex.a > hit.z && i>=1) return 0.3-length(hit-ro);\n        //if (i >= 5) return tex.aaa;\n        \n        // top hit -> looking at sun\n        if (far_dist.z < max(far_dist.x, far_dist.y)) return float(0.0);\n        // now side hit or miss\n        \n        //advance the ray to closest edge\n        vec3 next_hit = hit + rd*min(far_dist.x, far_dist.y);\n        if (hit == next_hit) {\n            next_hit = hit + rd*0.001;\n        }                \n        hit = next_hit;\n    }    \n    // don't know yet...\n    return float(0.9);\n\n}\n\n\nvec3 march (vec3 ro, vec3 rd, ivec2 cells){\n    // the idea is to march the ray to the next cell boundry.\n    // sample the texture and check height\n    // if the intersection ray is above the height, we missed this block\n    // if the intersection is below 0, we are outside the texture (return black)\n    // if the intersection is below the height, we hit the side (return some color?)\n    // issues: which side are we facing? (get this from rd?)    \n    vec3 sun_angle = normalize(vec3(0.8, 0.7, 0.5));\n    vec3 entry_point;\n    float t; //distance of current ray\n    // essentially which of the direcitons we are looking along x and y axis\n    vec2 dirs = sign(rd.xy) * -1.0;\n    if (dirs.x == 0.0 || dirs.y == 0.0) (dirs = vec2(1)); // avoid 0.0\n    vec3 d = ((1.0 * vec3(dirs, 1.0)) - ro) /rd; // distance to top, and near planes x/y\n    // if the distance to top is longest, we hit the other two front planes above the upper edge\n    if (d.z > d.x && d.z > d.y) {\n        t = d.z;\n        entry_point = ro + d.z*rd;        \n        // make sure this is grid alinged! (stair step function?\n        //entry_point.xy = floor(vec2(0.5) + entry_point.xy*vec2(cells.xy)*0.5)/(vec2(cells.xy)*0.5);\n        \n        // far miss? (we already know it's not hitting the front\n        if (abs(entry_point.x) > 1.0 || abs(entry_point.y) > 1.0) return sampleGround(ro, rd); vec3(0.1);\n        //return vec3(0.2, 0.2, 1.0); // DEBUG: we enter the top   \n        //return (entry_point);        \n    }\n    // if we hit the x plane before the y plane - we entry at the y plane\n    else if (d.x < d.y) {\n        t = d.y;\n        entry_point = ro + d.y*rd;\n        if (abs(entry_point.x) > 1.0) return sampleGround(ro, rd); //vec3(0.2, 0.1, 0.1); // far miss on the side\n        //return vec3(0.2, 1.0, 0.2); // DEBUG: we enter the Y side\n    }\n    else {// we hit the y plane first and are entrying through the x plane\n        t = d.x;\n        entry_point = ro + d.x*rd;\n        if (abs(entry_point.y) > 1.0) return sampleGround(ro, rd); //vec3(0.1, 0.2, 0.1); // far miss on the side\n        //return vec3(1.0, 0.2, 0.2); //DEBUG we enter the X side\n    }    \n    // TODO: the above is like a AABB, it can easily be simplified I suspect.\n    \n    \n    // near ground hit\n    //return entry_point;\n    if (entry_point.z < 0.0) return sampleGround(ro, rd); //vec3(0.5);\n    \n    //return entry_point;\n    vec3 front_hit = entry_point; // initialize as 1 to not hit the top on the first plane\n    \n    float l = 0.00; // light for the side angle\n    // new loop develops here  - what is the reasonable max?\n    for (int i = 0; i<(cells.x+cells.y)*2; i++){\n        ivec2 current_cell = worldToCell(front_hit, cells.xy);\n        \n        // rear miss -> end reached?\n        if (min(front_hit.x, front_hit.y) < -1.0) return sampleGround(ro, rd); //vec3(0.05*float(i)); // miss neg\n        if (max(front_hit.x, front_hit.y) > 1.0) return sampleGround(ro, rd); //vec3(0.1*float(i));// miss pos\n        \n        vec4 tex = sampleHeight(current_cell);        \n        // hit side?\n        if (front_hit.z < tex.a) {\n            vec3 sun_angle = normalize(vec3(0.8, 0.7, 0.5));\n            float shadow = shadow(front_hit, sun_angle, cells);\n            return vec3(tex.rgb) - shadow; \n        }\n        \n        // return tex.rgb; // debug\n        \n        // hit top, hit right, hit left, miss?\n        // distances to the rear planes .z can be ignored ?=?        \n        // where we actually march to the \"next\" far - wall.\n        \n        vec2 far_walls = cellToWorld(current_cell, cells, dirs);\n        \n        \n        // exit if we are the far wall, likely means we hit the end!\n        //if (far_walls.x == front_hit.x || far_walls.y == front_hit.y) return sampleGround(ro, rd);\n        \n        \n        // distance to next far walls\n        vec3 rear_d = (vec3(far_walls.xy, tex.a) - ro)/rd;\n        //return abs(vec3((rear_d.xyz))*0.5);\n        \n        // the min distance is the nearest wall, we step until there!\n        vec3 rear_hit = ro + rd*min(rear_d.x, rear_d.y); //t;        \n        // return rear_hit;\n        \n        // hit top?\n        if (tex.a > rear_hit.z) {            \n            vec3 hit_top = ro + rd*rear_d.z;\n            float shadow = shadow(hit_top, sun_angle, cells);\n            return vec3(tex.rgb) - shadow;            \n        }\n        \n        if (front_hit == rear_hit) {\n        // if we didn't actually advance, we should nudge here and hope for the best!\n            \n            // TODO: analytical value for this using acos(rd.z)??\n            rear_hit += rd*0.0001;\n        }\n        front_hit = rear_hit; // keep track for the next iteration\n        //return vec3(0.01);\n    }\n    //return sampleGround(ro, rd); // but we shouldn't get here!\n    return vec3(0.8); // percision issues where we ended the loop -.-\n    \n    \n}\n\n\n//TODO: sun angle and showdow casting (from the hit towards the sun...)?\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv normalized to [-1..1] for height with more width\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mo = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    // for when it's just idling...   \n    float azimuth = iTime*0.15 + mo.x;\n    float altitude = 0.7+cos(iTime*0.4)*0.15;      \n    if (sign(iMouse.z) > 0.0){\n        // orbiting camera setup\n        azimuth = PI*mo.x;\n        altitude = 0.5*PI*clamp(mo.y+1.0, -0.01, 0.99); // maybe just positive?\n    }\n    \n    // make sure you don't look \"below\"\n    altitude = clamp(altitude, HEIGHT_SCALE, PI);\n    \n    vec3 camera_pos = vec3(\n        cos(azimuth)*cos(altitude),\n        sin(azimuth)*cos(altitude),\n        sin(altitude));    \n    // the camera is always looking \"at\" the origin\n    vec3 look_dir = vec3(0.0, 0.0, HEIGHT_SCALE*0.5) - camera_pos;\n    \n    //camera_pos += look_dir * -5.0; // moving the camera \"back\" to avoid occlusions?\n    // two vectors orthogonal to this camera direction (tagents?)    \n    //vec3 look_u = camera_pos + vec3(-sin(azimuth), cos(azimuth), 0.0);\n    //vec3 look_v = camera_pos + vec3(sin(altitude)*-cos(azimuth), sin(altitude)*-sin(azimuth), cos(altitude));    \n    \n    // turns out analytically these aren't correct. so using cross instead -.-\n    vec3 look_u = normalize(cross(vec3(0.0, 0.0, -1.0), look_dir));\n    vec3 look_v = normalize(cross(camera_pos, look_u)); // is this faster?\n    // camera plane(origin of each pixel) -> barycentric?\n    \n    // orthographic zoom just makes the sensor smaller\n    float zoom = clamp(1.0 + cos(iTime*0.3), 0.05, 1.5);\n    vec3 camera_plane = camera_pos + (look_u*uv.x)*zoom + (look_v*uv.y)*zoom; // wider fov = larger \"sensor\"    \n        \n    vec3 col = march(camera_plane, look_dir, ivec2(iChannelResolution[0].xy)); // use iChannelResolution[0]?\n    \n    \n    \n    fragColor = vec4(vec3(col),1.0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    }
  ]
}