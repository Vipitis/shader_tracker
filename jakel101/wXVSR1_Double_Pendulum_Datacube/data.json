{
  "ver": "0.1",
  "info": {
    "id": "wXVSR1",
    "date": "1754338508",
    "viewed": 66,
    "name": "Double Pendulum Datacube",
    "username": "jakel101",
    "description": "this idea came when I watched https://youtu.be/9gQQAO4I1Ck\nthe screenspace essentially picks different initial conditions, keeping track of position and momentum for the inner and outer pendulum. use mouse to inspect a specific pendulum!\n",
    "likes": 4,
    "published": 3,
    "flags": 32,
    "usePreview": 0,
    "tags": [
      "simulation",
      "physics",
      "doublependulum",
      "datacube"
    ],
    "hasliked": 0,
    "retrieved": "2025-08-20T22:35:16.484822+00:00"
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        },
        {
          "id": 258,
          "src": "/media/previz/buffer01.png",
          "ctype": "buffer",
          "channel": 1,
          "sampler": {
            "filter": "nearest",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// Apache 2.0 no patents | ($)~~o~~($) |\n// imporvements and remixes welcome!\n\n// image pass lets you see the datacube and then pick any parallel timeline\n// use the mouse and click to view a specific timeline (whole screen)\n\n// previously derived in https://www.shadertoy.com/view/wc33WX\nfloat sdLineSegment(vec2 p, vec2 a, vec2 b) {\n    float d;    \n    float h = clamp(dot(p-a, b-a)/(length(b-a)*length(b-a)), 0.0, 1.0);\n    vec2 q = mix(a, b, h);    \n    d = length(p-q);\n    return d;\n}\n\nfloat sdBall(vec2 pos, float rad){\n    return length(pos) - rad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cube_st = uv; // sampling coords we need for the whole screen\n    uv *= 2.0;\n    vec2 cube_uv = uv;\n    uv -= 1.0;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m *= 2.0;\n    m -= 1.0;\n\n    ivec2 st = ivec2(iMouse.xy); //TODO remap to lineup with the front of the cube!\n    vec4 state = texelFetch(iChannel0, st, 0);\n    \n    // sanity checks!\n    // m = Cartesian2Polar(m); // Polar2Cartesian\n    // m = Polar2Cartesian(m.x, m.y); // Polar2Cartesian\n    \n    // sorta the background?\n    vec4 cube = texture(iChannel1, cube_st);\n    vec4 full = texture(iChannel0, cube_st); // this one for fullscreen!    \n    \n    vec3 col = mix(full, cube, clamp(-cos(iTime*0.3)*5.0, 0.0, 1.0)).rgb; // since .a channel also has information it might be worth looking at that too!\n    \n    // TODO these scale is not the same as used for the simulation, but should be proportional\n    vec2 inner_pos = Polar2Cartesian(state.x, 0.45);\n    vec2 outer_pos = inner_pos - Polar2Cartesian(state.z, -0.45); // why minus here?\n        \n    // TODO make pixel width analytically correct!\n    float pixel_width = 0.002;\n    \n    // TODO maybe make a draw func? void( inout bg, in fg, in mask)\n    float selector_dist = sdBall(uv - m, 0.02); // TODO what happens outside the area?\n    col = mix(col, vec3(0.8, 0.8, 0.4), smoothstep(pixel_width, -pixel_width, selector_dist));\n    float innter_rod = sdLineSegment(uv, vec2(0.0, 0.0), inner_pos);\n    col = mix(col, vec3(0.4, 0.4, 0.1), smoothstep(pixel_width, -pixel_width, innter_rod-0.01));\n    float outer_rod = sdLineSegment(uv, inner_pos, outer_pos);\n    col = mix(col, vec3(0.6, 0.6, 0.1), smoothstep(pixel_width, -pixel_width, outer_rod-0.01));\n    float pendulum = sdBall(uv - outer_pos, 0.02);\n    col = mix(col, vec3(1.0, 1.0, 0.1), smoothstep(pixel_width, -pixel_width, pendulum));\n    // Output to screen\n    \n    \n    float angle = atan(uv.x, uv.y);\n    float dist = length(uv)*2.0;\n    //col = vec3((angle/(PI*2.0))+ 0.5, 0.0, 0.0);\n    \n    fragColor = vec4(col, 1.0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    },
    {
      "inputs": [
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 257,
          "channel": 0
        }
      ],
      "code": "// this buffer does the physics simulation\n// outputs are as follows\n// .x position of the inner pendulum\n// .y rotational speed of the inner pendulum\n// .z position of the outer pendulum (in half rotations from the bottom) left/clockwise is negative\n// .w rotational speed of the outer pendulum clockwise is negative\n\n// substeps still scale the same time, but should be more \"accurate\" but results in why more noise too\n// energy is kept longer, breaks on really high numbers like > 110 or something :/\n#define SUBSTEPS 32\n// this can be changed to make it go \"faster\"\n#define GRAVITY -9.8\n\nvec4 init(vec2 uv) {\n    // this let's you set the initial conditions in relation to screenspace, so play around here and have fun\n    // requiers you to rewind time!\n    vec4 vals;\n    \n    vals.xz = uv; // rotation position\n    vals.yw = vec2(0.0); // start with 0 momentum!\n    //vals.xz = vec2(1.0); // start at the top\n    \n    // vals.x = 0.0; //for testing the outer part is just hanging\n    vals.yw = uv.yx*6.1; // add a lot of momentum!\n    \n    \n    //vals.wy = uv*0.01; // really close initial conditions (start athe the top)\n    \n    vals.y *= -1.0; // little flip so the default mouse position looks more interesting!\n    return vals;\n}\n\n// not used, left over from development!\nvoid simulate_single(inout vec2 pos, inout vec2 vel, float dt){\n    // assume the mass is 1!\n    vel.y += GRAVITY *dt;\n    \n    vec2 new_pos = pos + vel * dt;\n    // constraints\n    \n    // assume length is 1 and fixed to the origin\n    float error = 1.0 - length(new_pos);\n    vec2 corr = new_pos * -1.0 * error;\n\n    new_pos -= corr;\n\n    vec2 next_vel = (new_pos - pos) / dt;\n\n    // outputs\n    pos = new_pos;\n    vel = next_vel;\n}\n\n\nvoid simulate_double(float dt, inout vec2 pos_i, inout vec2 vel_i, inout vec2 pos_o, inout vec2 vel_o){\n    // reference: https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/06-pendulumShort.html MIT licnesed\n    vec2 new_pos_i;\n    vec2 new_vel_i;\n    vec2 new_pos_o;\n    vec2 new_vel_o;\n    \n    // step 1 apply gravity\n    vel_i.y += GRAVITY *dt;\n    vel_o.y += GRAVITY *dt;\n    new_pos_i = pos_i + vel_i * dt;\n    new_pos_o = pos_o + vel_o * dt;\n    \n    // step 2 constraints:\n    // assume masses and lengths is 1\n    // inner is fixed to 0,0 and outer is attached to inner    \n    vec2 delta = new_pos_o - new_pos_i;\n    float error_o = 1.0 - length(delta);\n    vec2 corr_i = error_o * -0.5 * delta; // 0.5 is the inverse mass\n    vec2 corr_o = error_o * -0.5 * delta;    \n    new_pos_i += corr_i; // one adds and one subtracts.. to move them towards their targets\n    new_pos_o -= corr_o;\n    \n    // TODO: is this order correct?\n    float error_i = 1.0 - length(new_pos_i);\n    corr_i = new_pos_i * -1.0 * error_i;\n    new_pos_i -= corr_i;\n    \n    \n    // step3 derive new velocities\n    new_vel_i = (new_pos_i - pos_i) /dt;\n    new_vel_o = (new_pos_o - pos_o) /dt;\n        \n    \n    //return not needed but we use inouts\n    pos_i = new_pos_i;\n    vel_i = new_vel_i;\n    pos_o = new_pos_o;\n    vel_o = new_vel_o;\n}\n\n// lets first try a single pendulumn!\nvec2 single(float a, float v){\n    // reference: https://youtu.be/XPZEeS70zzU\n\n    // returns them as polar again?\n    vec2 new;\n    vec2 pos = Polar2Cartesian(a, 1.0);\n    vec2 orth = Polar2Cartesian(a + 0.5, 1.0); // just an orthogonal vector we then scale\n    vec2 vel = orth*v;\n    \n    int i;\n    float dt = (iTimeDelta/float(SUBSTEPS));\n    for (i=0; i<SUBSTEPS; i++){\n        simulate_single(pos, vel, dt);\n    }    \n    vec2 new_pos = pos;\n    vec2 new_vel = vel;\n    \n    // reproject to polar coordinates:    \n    new.x = Cartesian2Polar(new_pos).x;\n    \n    vec2 next_orth = Polar2Cartesian(new.x + 0.5, 1.0);\n    new.y = length(new_vel)*sign(dot(new_vel,next_orth));\n    new.y = dot(new_vel, next_orth);\n    return new;\n}\n\nvec4 double_pendulum(vec4 state){\n    // decode positions and velocities\n    float lenght_i = 1.0;\n    float length_o = 1.0;\n    //TODO where do we put the lengths?\n    float angle_i = state.x;\n    float momentum_i = state.y;                \n    vec2 pos_i = Polar2Cartesian(angle_i, lenght_i);\n    vec2 vel_i = Polar2Cartesian(angle_i+0.5, 1.0)*momentum_i;\n    \n    float angle_o = state.z;\n    float momentum_o = state.w;\n    vec2 pos_o = Polar2Cartesian(angle_o, length_o);\n    pos_o = pos_i + pos_o; // because the polar coordinates were centered.\n    vec2 vel_o = Polar2Cartesian(angle_o+0.5, 1.0)*momentum_o;\n    vel_o = vel_i + vel_o;\n    \n    int i;\n    float dt = (iTimeDelta/float(SUBSTEPS));\n    for (i=0; i<SUBSTEPS; i++){\n        // sanity check here\n        //simulate_single(pos_i, vel_i, dt);\n        //simulate_single(pos_o, vel_o, dt);\n        simulate_double(dt, pos_i, vel_i, pos_o, vel_o);\n    }\n    \n    // reproject to polar coordinates:\n    vec2 next_i;\n    next_i.x = Cartesian2Polar(pos_i).x;\n    vec2 orth_i = Polar2Cartesian(next_i.x+0.5, 1.0);\n    next_i.y = length(vel_i)*sign(dot(vel_i,orth_i));\n    next_i.y = dot(vel_i, orth_i);\n    \n    vec2 next_o;\n    vec2 pos_o_rel = pos_o - pos_i; // we only store the relative position and motion of the outer pendulum\n    next_o.x = Cartesian2Polar(pos_o_rel).x;\n    vec2 orth_o = Polar2Cartesian(next_o.x+0.5, 1.0);\n    vec2 vel_o_rel = vel_o - vel_i;\n    next_o.y = length(vel_o_rel)*sign(dot(vel_o_rel,orth_o));\n    next_o.y = dot(vel_o_rel, orth_o);\n    \n    // fix the one element for testing\n    //next_i = vec2(0.0, 0.0);\n    //next_o = vec2(0.0, 0.0);\n    vec4 new_state = vec4(next_i, next_o);\n    return new_state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1..1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    ivec2 st = ivec2(fragCoord);\n    vec4 prev = texelFetch(iChannel0, st, 0);\n    if (iFrame < 2) { // maybe a fix for resizing here too?\n        prev = init(uv);        \n    }\n    //vec4 next = single(prev.x, prev.y).xyxy;\n    vec4 next = double_pendulum(prev);\n    //next.zw = vec2(0.0,0.0);\n    //next = simulate(prev.xy, prev.zw, iTimeDelta);\n    \n       \n    vec4 col = vec4(next);\n    \n    fragColor = vec4(col);\n}",
      "name": "Buffer A",
      "description": "",
      "type": "buffer"
    },
    {
      "inputs": [
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        },
        {
          "id": 258,
          "src": "/media/previz/buffer01.png",
          "ctype": "buffer",
          "channel": 1,
          "sampler": {
            "filter": "nearest",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 258,
          "channel": 0
        }
      ],
      "code": "// this buffer basically just shows a fake 3D datacube\n// by shifting the previous frame over and then reading the next state!\n\n// TODO: maybe do this in pixels instead?\n#define SHIFT vec2(0.005, 0.002)\n\nvec4 init(vec2 uv){\n\n    return vec4(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 new_st = (uv*2.0) -1.0;\n    float new_mask = float(new_st.x > 0.0 || new_st.y > 0.0);\n    \n    vec2 prev_st = uv - SHIFT;        \n    vec4 prev = texture(iChannel1, prev_st);    \n        \n    if (prev_st.x < 0.0 || prev.st.y < 0.0) {\n        prev = vec4(0.0); // avoid the wrapping to the left\n    }\n    if (prev_st.x < 0.5 && prev_st.y < 0.5){\n        // sorta a fake shadow?\n        prev *= clamp(length(max(abs(uv.x-0.25), abs(uv.y-0.25)))+0.5, 0.0, 1.0);\n    }\n    prev *= 0.99; // darker everything too\n    vec4 next = texture(iChannel0, new_st);\n    // TODO abs or shift or something to get all values in the visible range!\n    // for display we want to see it\n    // next = abs(next); // too much symmetry\n    // next += 0.5; // no black?\n    next = clamp(next, vec4(0.0), vec4(1.0)); // maybe scale instead with some exp function or similar\n    \n    // TODO: make black transparent here?\n    vec4 col = mix(next, prev, new_mask);\n\n    \n    // Output to screen\n    fragColor = vec4(col);\n}",
      "name": "Buffer B",
      "description": "",
      "type": "buffer"
    },
    {
      "inputs": [],
      "outputs": [],
      "code": "// functions I need for the simulation and the vizualization - they get to be shared here!\n\n# define PI 3.141592\n\n\n// zero seems to be up and 1 is donw -.-\nvec2 Polar2Cartesian(float rot, float dist){\n    rot -= 0.5; // is this even correct anymore?\n    rot *= PI;    \n    vec2 res = vec2(cos(rot)*dist, sin(rot)*dist);    \n    return res;\n}\n\nvec2 Cartesian2Polar(vec2 pos){\n    float rot, dist;\n    dist = length(pos);\n    rot = atan(pos.y, pos.x);\n    rot /= PI;\n    rot += 0.5;\n    return vec2(rot, dist);\n}\n",
      "name": "Common",
      "description": "",
      "type": "common"
    }
  ]
}