{
  "ver": "0.1",
  "info": {
    "id": "wc2yWh",
    "date": "1756592684",
    "viewed": 83,
    "name": "glass ball bouncing on heightmap",
    "username": "jakel101",
    "description": "I wanted to try 3D physics ontop of my heightmap shader... first goal is a single ball - but maybe we can do a 2nd one. (one glass and one light?)",
    "likes": 5,
    "published": 3,
    "flags": 32,
    "usePreview": 0,
    "tags": [
      "25d",
      "heightmap",
      "physics",
      "pathracing"
    ],
    "hasliked": 0,
    "retrieved": "2025-09-09T21:55:41.107497+00:00"
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// Apache 2.0 no patents \\_%_/\n\n/* Image pass shader to draw a texture/buffer/input as a heightmap\n* with some pathtracing as pillars of pixels.\n* Meant to be used in multiple projects and therefore\n* easily configurable at the top with a few macros\n*\n* selflink: https://www.shadertoy.com/view/M3VBWt\n* other projects using this shader/framework: https://www.shadertoy.com/playlist/mX2cD3\n* \n* work in progress:\n* todo(ideas):\n* - infinite/LOD tiles?\n* - DDA like traversal\n* - cleanup as usual\n* feedback/improvements welcome here.\n*/\n\n\n# define PI 3.141592653\n\n\n# define CELLS ivec2(64)\n//# define CELLS ivec2(3)\n\n// unsure yet where to bring this!\n# define SUN normalize(vec3(sin(iDate.w*0.5), cos(iTime), HEIGHT_SCALE*1.5))\n// normalize(vec3(3.0, -5.0, 2.0))\n\n// horizontal FOV, if you use negative values the camera will be orthographic!\n// examples:\n// FOV -1.0 for orthographic (sensor size)\n// FOV 90.0 for perspective wide\n// FOV 45.0 for perspective narower\n# define FOV 90.0\n\n// how far \"behind\" the camera is behind the arcball\n# define CAMERA_DIST 0.15\n\n\n// TODO one variable to change between sampled and direct light\n// 0 -> directional light\n// 1 -> point light\n// 2 -> MIS? (one light, one sampled?)\n// 3+ -> bounces//samples?\n# define BOUNCES 4\n# define SAMPLES 8\n\nstruct Material{\n    vec3 col; // ground color (or texture?)\n    float emissivity; //emitted light in some unit?\n    float roughness; // invers reflectivity, sorta\n    float translucency; // something like 1.0 for glass and 0.0 for solids? -> rays split/sample/refract??\n    float IOR; // index of refraction\n};\n\n// edit these here to change the look and feel!\nMaterial chalk = Material(vec3(1.0),           0.0,  0.35,  0.0, 1.3);\nMaterial ground = Material(vec3(0.5),          0.0,  0.15,  0.0, 0.0);\nMaterial sky = Material(vec3(0.02, 0.3, 0.85), 0.5,  0.90,  0.0, 0.0);\nMaterial glass = Material(vec3(1.0),           0.05,  0.02,  1.0, 1.33);\n\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n    vec3 inv_dir; // for speedup?\n};\n\n// helper constructor\nRay newRay(vec3 ro, vec3 rd){\n    return Ray(ro, rd, 1.0/rd);\n}\n\n\nstruct IntersectionInfo{\n    bool hit;\n    // rest illdefined for a miss\n    bool inside;\n    vec3 entry;\n    vec3 exit;\n    vec3 entry_norm;\n    vec3 exit_norm;\n    float entry_dist;\n    float exit_dist;\n};\n\n// sorta reference: https://tavianator.com/2022/ray_box_boundary.html\nIntersectionInfo AABB(vec3 center, vec3 size, Ray ray){\n    IntersectionInfo res;\n\n    vec3 pos = center + size;\n    vec3 neg = center - size;\n\n    vec3 pos_dist = (pos-ray.origin) * ray.inv_dir;\n    vec3 neg_dist = (neg-ray.origin) * ray.inv_dir;\n\n    vec3 min_dist = min(pos_dist, neg_dist);\n    vec3 max_dist = max(pos_dist, neg_dist);\n\n    res.entry_dist = max(max(min_dist.x, min_dist.y), min_dist.z);\n    res.exit_dist = min(min(max_dist.x, max_dist.y), max_dist.z);\n\n    // normals point away from the center\n    res.entry_norm = -sign(ray.dir) * vec3(greaterThanEqual(min_dist, vec3(res.entry_dist)));\n    res.exit_norm = sign(ray.dir) * vec3(lessThanEqual(max_dist, vec3(res.exit_dist)));\n\n    // essentially methods?\n    res.entry = ray.origin + ray.dir*res.entry_dist;\n    res.exit = ray.origin + ray.dir*res.exit_dist;\n\n    res.hit = res.entry_dist < res.exit_dist && res.exit_dist > 0.0;\n    res.inside = res.entry_dist < 0.0; // entry behind us\n\n    return res;\n}\n\n// with help from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection.html\nIntersectionInfo Sphere(vec3 center, float radius, Ray ray){\n    IntersectionInfo res;\n    vec3 local = ray.origin - center;\n        \n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0* dot(ray.dir, local);\n    float c = dot(local, local) - pow(radius,2.0);\n        \n    float discriminant = pow(b,2.0) - 4.0*a*c;\n    \n    res.hit = discriminant >= 0.0;\n    \n    float t0 = (-b + sqrt(discriminant))/ (2.0*a);\n    float t1 = (-b - sqrt(discriminant))/ (2.0*a);\n\n    res.entry_dist = min(t0, t1);\n    res.exit_dist = max(t0, t1);\n    \n    if (res.entry_dist < 0.0 && res.exit_dist < 0.0){\n        res.hit = false;\n    }\n\n    res.entry = ray.origin + ray.dir * res.entry_dist;\n    res.exit = ray.origin + ray.dir * res.exit_dist;\n\n    res.entry_norm = normalize(res.entry - center);\n    res.exit_norm = normalize(res.exit - center);\n    \n    res.inside = res.entry_dist < 0.0 && res.exit_dist > 0.0; // entry behind us\n\n    return res;\n}\n\nvec4 sampleHeight(ivec2 cell){\n    // to allow for more complex math to determine height\n    // .rgb should just return the texture color or some modification of it\n    //cell.x = (cell.x + iFrame) % int(iChannelResolution[0].x); // fun texture scroll\n    vec4 tex = texelFetch(iChannel0, cell, 0);\n    vec4 res;\n    res.a = tex.r + tex.g + tex.b; // we do height by a sum of the color for now\n    res.a *= 0.33;\n    res.rgb = tex.rgb; // simply copy the color as the \"texture\" for now\n    \n    // res.a = tex.a; // debug/use existing height data.\n    res.a *= HEIGHT_SCALE;\n    return res;\n}\n\n\n\nIntersectionInfo pillar_hits(ivec2 cell, float height, Ray ray){\n    // let's move the pillar into world space by having it's center + extends\n\n    vec3 extend = vec3(1.0/vec2(CELLS), abs(height)*0.5);\n    vec3 p = vec3(cell.xy, abs(height)*0.5);\n    p.xy *= extend.xy;\n    p.xy *= 2.0;\n    p.xy -= 1.0 - extend.xy; // not quite the offset?\n    //extend.z = extend.y; // make them cubes?\n\n    // for the case of clouds the box is at the top?\n    if (height < 0.0){\n        p.z = HEIGHT_SCALE*(1.0-abs(height*0.5));\n    }\n\n    // TODO: redo this math when less asleep...\n    IntersectionInfo res = AABB(p, extend, ray);\n    return res;\n}\n\n\n\n// from: https://www.shadertoy.com/view/7l3yRn\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n// also from above\n// TODO collaplse into one function!\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    float z = 2.0 * random_numbers[1] - 1.0;\n    float phi = 2.0 * PI * random_numbers[0];\n    float x = cos(phi) * sqrt(1.0 - z * z);\n    float y = sin(phi) * sqrt(1.0 - z * z);\n    return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n    vec3 direction = sample_sphere(random_numbers);\n    if (dot(normal, direction) < 0.0)\n        direction -= 2.0 * dot(normal, direction) * normal;\n    return direction;\n}\n\n\nstruct RaycastInfo{\n    bool hit; // if negative, the rest is undefined.\n    float dist; // hit_info.entry_dist redundant?\n    //ivec2 cell; //current_cell?\n    IntersectionInfo hit_info; //has the entry norm etc.\n    vec3 col; // TODO: replace with material\n    //Ray ray; //just as a reference?\n};\n\n\nRaycastInfo raycast(Ray ray){\n    // cast the ray untill there is a hit or we exit the box\n    // \"any hit\" shader?\n    RaycastInfo result;\n    \n    IntersectionInfo box = AABB(vec3(0.0, 0.0, HEIGHT_SCALE*0.5), vec3(1.0, 1.0, HEIGHT_SCALE*0.5), ray);\n\n    vec3 entry = box.entry;\n\n    if (!box.hit){\n        // if we \"MISS\" the whole box (not inside?).\n        result.hit = false;\n        return result;\n        \n    }\n    // everything below here is inside the box\n    if (box.inside){\n        // if we are \"inside\" the entry should just be ro!\n        entry = ray.origin; // maybe problems with distance caluclations at the end?\n    }\n    \n    ivec2 current_cell = worldToCell(entry); // TODO: this one is problematic!\n    int i;\n    ivec2 max_cells = CELLS - min(current_cell, CELLS-current_cell);\n    int max_depth = (max_cells.x + max_cells.y)+2; // could also be min!\n    for (i = 0; i < max_depth; i++){\n        if (current_cell.x < 0 || current_cell.x >= CELLS.x ||\n            current_cell.y < 0 || current_cell.y >= CELLS.y){\n            // we marched far enough are are \"outside the box\" now!\n            result.hit = false;            \n            return result;\n        }\n\n        vec4 tex = sampleHeight(current_cell);\n        IntersectionInfo pillar = pillar_hits(current_cell, tex.a, ray);\n\n        if (pillar.hit) {\n            // \"any hit\" (side/top/bot) -> loop ends here\n            // do a little bit of light sim by doing diffuse \"block of chalk\"\n            vec3 col = tex.rgb;\n            // TODO materail decision here?\n            result.hit = true;\n            result.hit_info = pillar;\n            result.dist = pillar.entry_dist;\n            result.col = col;\n            return result;            \n        }\n\n        // check if our exit distance larger than the box, means we should be at the final pillar...\n        if (pillar.exit_dist >= box.exit_dist){\n            result.hit = false;\n            return result; // do we ever get here?\n        }\n\n        // the step\n        // TODO: DDA style decision\n        ivec2 next_cell = current_cell + ivec2(pillar.exit_norm.xy);\n        if (next_cell == current_cell){\n            // in this case we do another raycast - but without any Z component\n            // so the vector is sideways and points to a new cell!\n            vec3 flat_rd = vec3(ray.dir.xy, 0.0);\n            Ray flat_ray = Ray(ray.origin, flat_rd, 1.0/flat_rd);\n\n            IntersectionInfo grid = pillar_hits(current_cell, 1.0, flat_ray);\n            next_cell += ivec2(grid.exit_norm.xy); // TODO check if this norm is correct!\n        }\n        // for next iteration\n        current_cell = next_cell;\n    }\n    \n    result.hit = false;\n    return result;\n}\n\n// more like a bad shadowmap\n// idea for the future: precompute the horizon per pixel: https://youtu.be/LluCbGdi-RM\nfloat directional_light(Ray sun_ray, vec3 normal){\n    // return the amount of shadowed?\n    // we are now marching upwards from some hit\n    // ro is essentially the point we started from\n    // rd is the sun angle\n    RaycastInfo res = raycast(sun_ray);\n    //return res.a;\n    \n    //TODO: intensity/color?\n    \n    float amt = 1.0;\n    \n    \n    if (!res.hit){// || (ro + rd*res.a).z >= HEIGHT_SCALE){\n        // miss means full sunlight!\n        amt = max(0.0, dot(sun_ray.dir, normal));\n    }\n    else {\n        // TODO: use distance?\n        amt = 0.1; // additional ambient light from here?\n    }\n    return amt;\n}\n\n// struct for lights? colored light?\nfloat point_light(vec3 start, vec3 light_pos, float light_intensity, vec3 normal){\n    float amount;\n    \n    vec3 light_dir = normalize(light_pos - start);\n    float light_dist = distance(start, light_pos);\n    // Ray(hit+0.001*SUN, SUN, 1.0/SUN);\n    Ray light_cast = Ray(start + 0.001*light_dir, light_dir, 1.0/light_dir);\n    RaycastInfo res = raycast(light_cast);\n    \n    if (!res.hit || res.dist > light_dist) {\n        // either we miss geometry or we hit gometry behind the light\n        amount = inversesqrt(light_dist)* light_intensity;\n        amount *= max(0.0, dot(normal, light_dir));\n    }\n    else {\n        // hit an intersection before the light, so don't see the light!\n        amount = 0.0;        \n    }\n    \n    // TODO still needs dot normal!\n    return amount;\n}\n\n\n\n// copied from https://www.shadertoy.com/view/M3jGzh\nfloat checkerboard(vec2 check_uv, float cells){\n    check_uv *= cells/2.0;\n    float rows = float(mod(check_uv.y, 1.0) <= 0.5);\n    float cols = float(mod(check_uv.x, 1.0) <= 0.5);\n    return float(rows == cols);\n}\n\nstruct HitInfo{\n    Material mat;\n    float dist;\n    vec3 norm;\n    vec3 pos;\n    bool inside; // for doing glass rays!\n};\n\n\nHitInfo sampleGround(vec3 ro, vec3 rd){\n    HitInfo res;\n    // TODO: rename to sample skybox maybe? as the ground is sorta part of that...\n    float ground_height = 0.0;\n    float ground_dist = (ground_height-ro.z)/rd.z;\n    // TODO: use the actual sphere for the \"skybox\"\n    if (ground_dist < 0.0 ||ground_dist > 10.0) {\n        // essentially sky hit instead?\n        // just some random skybox right now... could be improved of course!\n        vec3 col = vec3(0.23, 0.59, 0.92)*exp(dot(SUN, rd)-0.8);\n        col = clamp(col, vec3(0.0), vec3(1.0));\n        \n        res.mat = sky;\n        \n        res.mat.col = col; // no longer matches with \"sky\" - so gotta change the above maybe?\n        \n        res.dist = 10.0;\n        res.pos = ro + rd*res.dist;\n        res.mat.emissivity *= clamp(smoothstep(res.dist - 8.1, res.dist- 3.0, res.pos.z), 0.0, 1.0);\n        res.norm = -rd;\n        return res; // some random distance that is positive!\n    }\n\n    vec3 ground_hit = ro + (rd * ground_dist);\n\n    float val = checkerboard(ground_hit.xy, 8.0)* 0.25;\n    val += 0.45;\n    //val *= 2.0 - length(abs(ground_hit));\n\n    // fake sun angle spotlight... TODO actual angle and normal calculation!\n    //val *= 2.5 - min(2.3, length((-SUN-ground_hit)));//,vec3(0.0,0.0,1.0));\n\n    vec3 col = vec3(val);\n    res.mat = ground;\n    res.mat.col = col;\n    res.dist = ground_dist;\n    res.pos = ground_hit;\n    res.norm = vec3(0.0, 0.0, 1.0);\n    return res;\n}\n\n// TODO for montecarlo we need an external loop around this!\nHitInfo scene(Ray camera, vec3 ball_pos, vec3 ball2_pos){\n    HitInfo res;\n    \n    // terrain\n    RaycastInfo terrain = raycast(camera);\n\n    // ball\n    IntersectionInfo ball = Sphere(ball_pos, BALL_SIZE, camera);\n    IntersectionInfo ball2 = Sphere(ball2_pos, BALL_SIZE, camera); // TODO: ballsize in .w data point? so they can some how change dynamically?\n\n    // five cases: just terrain hit, ball hit, both miss, both hit terrain closer, both hit ball closer\n    // idea: get all hits, then calculate closest (sorted?) and then return that. if none return background\n    // TODO: redo logic (dynamic arrays?)\n    \n    // easy solution: front to back... overdraws the ground tho.\n    res = sampleGround(camera.origin, camera.dir);\n    res.dist = 1000.0;\n\n    if (terrain.hit) { //  && (!ball.hit || terrain.dist < ball.entry_dist)\n        // terrain infront of the ball\n        res.dist = terrain.hit_info.entry_dist;\n        res.mat = chalk;\n        res.mat.col = terrain.col; // TODO: material construction\n        res.norm = terrain.hit_info.entry_norm;\n        res.pos = terrain.hit_info.entry;\n        res.inside = terrain.hit_info.inside;\n        if (res.inside) {\n            res.dist = terrain.hit_info.exit_dist;\n            res.norm = terrain.hit_info.exit_norm;\n            res.pos = terrain.hit_info.exit;\n        }\n        \n    } if (ball.hit && ball.entry_dist < res.dist) {\n        // ball infront of the terrain\n        res.dist = ball.entry_dist;\n        res.mat = glass; // TODO: glass material?\n        res.norm = ball.entry_norm;\n        res.pos = ball.entry;        \n        res.inside = ball.inside;\n        if (res.inside) {\n            res.dist = ball.exit_dist;\n            res.norm = ball.exit_norm;\n            res.pos = ball.exit;\n        }\n    } if (ball2.hit && ball2.entry_dist < res.dist) {\n        // ball infront of the terrain\n        res.dist = ball2.entry_dist;\n        res.mat = glass; // TODO: glass material?\n        res.mat.emissivity = 3.5; // 2nd ball is a light source!\n        res.norm = ball2.entry_norm;\n        res.pos = ball2.entry;        \n        res.inside = ball2.inside;\n        if (res.inside) {\n            res.dist = ball2.exit_dist;\n            res.norm = ball2.exit_norm;\n            res.pos = ball2.exit;\n        }        \n    } \n    \n\n    return res;\n}\n\n// follow ? https://www.shadertoy.com/view/7l3yRn\nstruct RayRadiance{\n    vec3 radiance;\n    vec3 throughput_weight;\n};\n\n// reading: https://www.pbr-book.org/4ed/Radiometry,_Spectra,_and_Color/Surface_Reflection\n// further: https://www.pbr-book.org/4ed/Reflection_Models\n// watching maybe: https://youtu.be/wA1KVZ1eOuA\nvec3 brsf(in vec3 rd, in HitInfo hit, inout vec3 next_dir, inout uvec2 seed){\n    // returns the outgoing radiance?\n    // as well as the next ray direction. (inout)\n    \n    Material mat = hit.mat;\n    vec3 norm = hit.norm;\n    // naive reflection model\n    vec3 perfect_reflection = reflect(rd, norm);\n    next_dir = mix(perfect_reflection, next_dir, mat.roughness);\n    \n    //native transmission model\n\n    vec2 randoms = get_random_numbers(seed);\n    if (randoms.x < mat.translucency) {\n        float IOR = hit.inside ? mat.IOR : 1.0/mat.IOR;\n        vec3 reflect_norm = hit.inside ? norm : -norm;\n        vec3 perfect_refraction = refract(rd, -reflect_norm, IOR);\n        next_dir = mix(perfect_refraction, -next_dir, mat.roughness);\n        //next_dir = perfect_refraction;\n        norm = reflect_norm;\n    }\n\n    vec3 outgoing = mat.col * 2.0 * max(0.0, dot(norm, next_dir));\n    return outgoing;\n}\n\n\n\n// factored out to function so the seed changes correctly due to inout -.-\nvec3 get_ray_radiance(Ray camera, vec3 ball_pos, vec3 ball2_pos, inout uvec2 seed){\n    //after get_ray_radiance in https://www.shadertoy.com/view/7l3yRn\n\n    vec3 radiance = vec3(0.0);\n    vec3 throughput_weight = vec3(1.0);\n\n    int i;\n    for(i=0; i<=BOUNCES; i++){\n        HitInfo first_hit = scene(camera, ball_pos, ball2_pos);\n        radiance += throughput_weight * first_hit.mat.emissivity;\n        \n        // initialize with random here??\n        vec3 next_dir = sample_hemisphere(get_random_numbers(seed), first_hit.norm);        \n        vec3 outgoing_radiance = brsf(camera.dir, first_hit, next_dir, seed);\n        \n        throughput_weight *= outgoing_radiance;\n        camera = newRay(first_hit.pos+0.0001*next_dir, next_dir);\n    }\n\n    return radiance;\n}\n\n\n\n// TODO: sample hemisphere function\n// TODO: brdf kinda function where it gives you a new direction based on material.\n// TODO: calucalte the light from that brdf too? HitInfo2 -> RayRadiance, next_dir\n// multiple importance sampling? following: https://lisyarus.github.io/blog/posts/multiple-importance-sampling.html\n// idea being we sample the direct light or direction light once, and then do one random sample. weight them 50/50?\n// TODO: call scene below and loop it?\n// 1. cast scene, 2. accumulate light, 3. get next dir, LOOP\n// add a MAX_bounces or SPP var at the top.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv normalized to [-1..1] for height with more width\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mo = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    \n    uvec2 seed = uvec2(fragCoord) ^ uvec2(iFrame << 16);\n    vec3 ball_pos = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    vec3 ball2_pos = texelFetch(iChannel0, ivec2(8,0), 0).xyz; // janky proof of concept for now!\n    //fragColor = texture(iChannel0, uv);\n    //return;\n\n    // for when it's just idling...\n    float azimuth = -1.9+iTime*0.1 + mo.x; // keeps a bit of residue of the mouse!\n    float altitude = 0.7+cos(1.5+iTime*0.25)*0.35;\n    if (sign(iMouse.z) > 0.0){\n        // orbiting camera setup\n        azimuth = PI*mo.x;\n        altitude = 0.5*PI*clamp(mo.y+1.0, -0.01, 0.99); // maybe just positive?\n    }\n\n    // make sure you don't look \"below\"\n    altitude = clamp(altitude, HEIGHT_SCALE*0.2, PI);\n\n    // a unit length orbit!\n    vec3 camera_pos = vec3(\n        cos(azimuth)*cos(altitude),\n        sin(azimuth)*cos(altitude),\n        sin(altitude));\n    // the camera is always looking \"at\" the origin or half way above it\n        \n    camera_pos = ball_pos + CAMERA_DIST*camera_pos;\n    \n    vec3 nodal = vec3(0.0, 0.0, HEIGHT_SCALE*0.5);\n    vec3 look_at = mix(ball_pos, nodal, 0.05); // so it's not crazy locked on \n    \n    vec3 look_dir = normalize(look_at-camera_pos);\n\n\n    // TODO moving the camera in and out over time??\n    //camera_pos += look_dir * CAMERA_DIST; // moving the camera \"back\" to avoid occlusions?\n    // two vectors orthogonal to this camera direction (tagents?)\n    //vec3 look_u = camera_pos + vec3(-sin(azimuth), cos(azimuth), 0.0);\n    //vec3 look_v = camera_pos + vec3(sin(altitude)*-cos(azimuth), sin(altitude)*-sin(azimuth), cos(altitude));\n\n\n    // turns out analytically these aren't correct. so using cross instead -.-\n    vec3 up_vec = vec3(0.0, 0.0, 1.0);\n    vec3 look_u = normalize(cross(look_dir, up_vec));\n    vec3 look_v = normalize(cross(look_u, look_dir)); // is this faster?\n    // camera plane(origin of each pixel) -> barycentric?\n\n    vec3 camera_plane;\n    vec3 ray_dir;\n    vec3 ray_origin;\n\n    if (FOV > 0.0){\n        // assume a pinhole camera.\n        // FOV is the horizontal fov, the given focal length becomes:\n        // the 1.0 is the sensor height.\n        float focal_length = 1.0/tan(radians(FOV*0.5));\n\n        // the ro\n        camera_plane = camera_pos - (look_dir*focal_length) + ((look_u*uv.x) + (look_v*uv.y))*-1.0; // inverted here to see upright\n        ray_origin = camera_pos;\n\n        // the rd\n        ray_dir = camera_pos-camera_plane;\n        ray_dir = normalize(ray_dir);\n    }\n\n    else {\n        // negative FOV values are interpreted as a sensor size for a orthographic camera!\n        // horizontal sensor size, -1 would be something sensible... everything else is far away\n        float sensor_size = FOV*0.5*-1.0;\n        camera_plane = camera_pos + ((look_u*uv.x)+(look_v*uv.y))*sensor_size; // wider fov = larger \"sensor\"\n        ray_dir = look_dir;\n        ray_origin = camera_plane;\n    }\n\n    // todo extract to a function\n    // Ray in -> material/normal out?\n    // caluclate and aggregate light throughput?\n    // new ray direction based on sampled material/refraction?\n\n    Ray camera = newRay(ray_origin, ray_dir);\n    vec3 out_col = vec3(0.0);\n\n    int j;\n    for(j=0; j<SAMPLES; ++j){\n        vec3 rad = get_ray_radiance(camera, ball_pos, ball2_pos, seed);\n        out_col += rad;\n    }\n    // average color over all samples\n    out_col /= float(SAMPLES);\n    \n    // TODO gamma correction?\n    fragColor = vec4(out_col, 1.0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    },
    {
      "inputs": [
        {
          "id": 30,
          "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
          "ctype": "texture",
          "channel": 1,
          "sampler": {
            "filter": "nearest",
            "wrap": "repeat",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        },
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 257,
          "channel": 0
        }
      ],
      "code": "//buffer pass does the physics simulation!\n// lots of todo to find here!\n\n\n# define SUBSTEPS 16\n# define GRAVITY -9.8\n# define SIM_SPEED 0.3\n\nvec4 init(vec2 uv){\n    //return vec4(uv.x, uv.y, 0.5, 1.0);\n    vec4 tex = texture(iChannel1, uv/vec2(CELLS));    \n    // TODO add dt here\n    return tex;\n}\n\n\n// TODO: can't put in common as the sampler is requied - will break wgpu -.-\nvec4 sampleHeight(vec4 tex, float anim_time, vec2 uv){\n\n    // modulate from above: \n    tex = 0.5+ sin(tex*6.0 + 0.6*(anim_time)+vec4(uv.x,uv.y,1,0)) * 0.5;\n\n    //vec4 tex = texelFetch(iChannel0, cell, 0); // TODO: skip resample\n    vec4 res;\n    res.a = tex.r + tex.g + tex.b; // we do height by a sum of the color for now\n    res.a *= 0.33;\n    res.rgb = tex.rgb; // simply copy the color as the \"texture\" for now\n    \n    // res.a = tex.a; // debug/use existing height data.\n    res.a *= HEIGHT_SCALE;\n    return res;\n}\n\n\n// TODO box - sphere intersection?\n// sph, box -> error/direction/scale\n// sum it all up, recaclucalte velocity? (Position based dynamics?)\n\n\n// TODO: ball box intersection\n// TODO ball, ball intersection? (how to cross write?)\n\n\n\n// TODO: fix the bounces and rewatch https://youtu.be/j84zJ06wnVA\nvoid animate(float dt, int sub_step, in vec2 uv, in vec3 pos, in vec3 vel, out vec3 new_pos, out vec3 new_vel){    \n    new_vel = vel;\n    new_vel.z += GRAVITY *dt;\n    new_pos = pos + new_vel *dt;\n    \n    // basic bouce on the ground:\n    // TODO check the one pillar on the contact point my mapping uv back to texture I guess.\n    float anim_time = iTime + float(sub_step) * dt; \n    vec4 tex = init(new_pos.xy);\n    float height = sampleHeight(tex, dt, uv).a;\n    if ((new_pos.z - RADIUS) < height) {\n        // TODO restitution\n        new_pos.z = pos.z; // TODO don't stop here\n        new_vel.z *= -1.0;\n    }\n    \n    // sides at 1.0 and -1.0 in all directions\n    // TODO bvec here?\n    // probably scale by the overshoot...\n    if ((abs(new_pos.x) + RADIUS) > 1.0) {\n        float error = (abs(new_pos.x) + RADIUS) - 1.0;\n        new_vel.x *= -1.0;\n        \n        new_pos.x += new_vel.x*error;        \n    }\n    if ((abs(new_pos.y) + RADIUS) > 1.0) {\n        new_pos.y = pos.y;\n        new_vel.y *= -1.0;\n    }\n    \n    // TODO check all pillars below the ball!\n    // TODO sidewalls bounce a pillar\n    // how to do a sideways bounce?\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // todo not to the limited 64x64 scale of the world -.-\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    if (fragCoord.x > 65.0 || fragCoord.y > 65.0){\n        discard;\n    }\n    \n    ivec2 st = ivec2(fragCoord);\n    // since we need to store at least 6 values, we mask them with bools here\n    // TODO maybe macros?\n    \n    // store a ball per row? // TODO -> NUM_BALLS common define?\n    int BALL_ID = int(fragCoord.x);    \n    ivec2 POS_MEM = ivec2(BALL_ID,0);\n    ivec2 VEL_MEM = ivec2(BALL_ID,1);\n    bool STORE_POS = (st == POS_MEM) ? true : false;\n    bool STORE_VEL = (st == VEL_MEM) ? true : false;\n    \n    vec3 pos = texelFetch(iChannel0, POS_MEM, 0).xyz;\n    vec3 vel = texelFetch(iChannel0, VEL_MEM, 0).xyz;    \n    \n    vec4 col = vec4(0.0);\n    vec4 tex; // values at the \"start\" of this timestep?\n    if (iFrame < 2){\n        col = init(vec2(st)/64.0);\n        pos = vec3(0.0, 0.0, 0.75);\n        vel = vec3(uv.x, 2.5, 0.1);\n    }\n    // if (!STORE_POS || !STORE_VEL)\n    else{\n        tex = init(vec2(st));\n        col = sampleHeight(tex, iTime, uv);\n        //discard;        \n    }\n    \n    vec3 new_pos = pos;\n    vec3 new_vel = vel;\n    \n    float dt = (iTimeDelta/float(SUBSTEPS))*SIM_SPEED;\n    // TODO extract to function\n    int i;\n    for (i=0; i < SUBSTEPS; i++){\n        animate(dt, i, uv, pos, vel, new_pos, new_vel);\n        pos = new_pos;\n        vel = new_vel;\n    }        \n    \n    // TODO maybe \n    // write only the relavent part?\n    col.rgb = STORE_POS ? new_pos : col.rgb;\n    col.rgb = STORE_VEL ? new_vel : col.rgb;\n    fragColor = col;\n}",
      "name": "Buffer A",
      "description": "",
      "type": "buffer"
    },
    {
      "inputs": [],
      "outputs": [],
      "code": "// a few shared things\n# define RADIUS 0.025\n# define BALL_SIZE RADIUS\n\n\n# define CELLS ivec2(64)\n# define HEIGHT_SCALE 0.2\n\n\nivec2 worldToCell(vec3 p) {\n    // move world space again\n    p += 1.0;\n    p *= 0.5;\n    ivec2 st = ivec2((p.xy*vec2(CELLS.xy)));\n    // TODO: find an actual solution to the edge cases!\n    st = min(st, CELLS -1);\n    return st;\n}\n",
      "name": "Common",
      "description": "",
      "type": "common"
    }
  ]
}