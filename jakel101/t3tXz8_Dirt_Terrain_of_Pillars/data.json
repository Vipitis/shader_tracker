{
  "ver": "0.1",
  "info": {
    "id": "t3tXz8",
    "date": "1753142287",
    "viewed": 124,
    "name": "Dirt Terrain of Pillars",
    "username": "jakel101",
    "description": "this is meant to be a submission for https://itch.io/jam/acerola-dirt-jam\nnot VOXELS, height is not quantized!\ntracked changes on [url=https://www.shadertoy.com/view/t3tXz8]GitHub[/url]",
    "likes": 13,
    "published": 3,
    "flags": 48,
    "usePreview": 0,
    "tags": [
      "terrain",
      "pathtracing",
      "dirtjam"
    ],
    "hasliked": 0,
    "retrieved": "2025-07-29T21:56:53.603998+00:00"
  },
  "renderpass": [
    {
      "inputs": [
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 37,
          "channel": 0
        }
      ],
      "code": "// Apache 2.0 no patents /^\u00a7^\\\n\n// Image pass implemented as my heightmap pathtracing project: https://www.shadertoy.com/view/M3VBWt\n// with a couple tweaks to make it work for this example :)\n\n// SOME BUGS: (or todos)\n// the raycast doesn't work \"upwards\" as expected. so camera stays outside and orbiting\n// clouds are composited ontop and don't care for order or distance (so they \n// clouds have a strong moire pattern because traversal abbrpuptly begins at the top plane\n\n# define PI 3.141592653\n// tweaked with 0.5 in mind others could look wonky...\n# define HEIGHT_SCALE 0.55\n\n// this is square but still depends on the canvas resolution!\n# define CELLS ivec2(min(512.0,min(iChannelResolution[0].x, iChannelResolution[0].y)))\n\n// unsure yet where to bring this!\n# define SUN normalize(vec3(sin(iDate.w*0.05), cos(iTime*0.2), HEIGHT_SCALE*1.1))\n// normalize(vec3(3.0, -5.0, 2.0))\n\n// playing with this, using my imgui parser - https://github.com/pygfx/shadertoy/pull/46\n# define CLOUD_DENSITY 20.0\n\n\n// horizontal FOV, if you use negative values the camera will be orthographic!\n// examples:\n// FOV -1.0 for orthographic (sensor size)\n// FOV 90.0 for perspective wide\n// FOV 45.0 for perspective narower\n# define FOV 90.0\n\nivec2 worldToCell(vec3 p) {\n    \n    // move world space again\n    p += 1.0;\n    p *= 0.5;\n    ivec2 st = ivec2((p.xy*vec2(CELLS.xy)));\n    // TODO: find an actual solution to the edge cases!\n    st = min(st, CELLS -1);\n    return st;\n}\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n    vec3 inv_dir; // for speedup?\n};\n\nstruct BoxHit{    \n    bool hit;\n    // rest illdefined for a miss\n    bool inside;\n    vec3 entry;\n    vec3 exit;\n    vec3 entry_norm;\n    vec3 exit_norm;\n    float entry_dist;\n    float exit_dist;\n};\n\n// sorta reference: https://tavianator.com/2022/ray_box_boundary.html\n// TODO should be a HitInfo as the same will work for other intersections down the line.\nBoxHit AABB(vec3 center, vec3 size, Ray ray){\n    BoxHit res;\n        \n    vec3 pos = center + size;\n    vec3 neg = center - size;\n    \n    vec3 pos_dist = (pos-ray.origin) * ray.inv_dir;\n    vec3 neg_dist = (neg-ray.origin) * ray.inv_dir;\n    \n    vec3 min_dist = min(pos_dist, neg_dist);\n    vec3 max_dist = max(pos_dist, neg_dist);\n    \n    res.entry_dist = max(max(min_dist.x, min_dist.y), min_dist.z);\n    res.exit_dist = min(min(max_dist.x, max_dist.y), max_dist.z);\n    \n    // essentially methods?\n    res.hit = res.entry_dist < res.exit_dist && res.exit_dist > 0.0;\n    res.inside = res.entry_dist < 0.0; // entry behind us\n    \n    res.entry = ray.origin + ray.dir*res.entry_dist;\n    res.exit = ray.origin + ray.dir*res.exit_dist;\n    \n    // normals point away from the center\n    res.entry_norm = -sign(ray.dir) * vec3(greaterThanEqual(min_dist, vec3(res.entry_dist)));\n    res.exit_norm = sign(ray.dir) * vec3(lessThanEqual(max_dist, vec3(res.exit_dist)));\n    \n    return res;\n}\n\n\nBoxHit pillar_hits(ivec2 cell, float height, Ray ray){    \n    // let's move the pillar into world space by having it's center + extends\n    \n    vec3 extend = vec3(1.0/vec2(CELLS), abs(height)*0.5);\n    vec3 p = vec3(cell.xy, abs(height)*0.5);    \n    p.xy *= extend.xy; \n    p.xy *= 2.0;\n    p.xy -= 1.0 - extend.xy; // not quite the offset?\n    //extend.z = extend.y; // make them cubes?\n    \n    // for the case of clouds the box is at the top?\n    if (height < 0.0){\n        p.z = HEIGHT_SCALE*(1.0-abs(height*0.5));\n    }    \n    \n    // TODO: redo this math when less asleep...\n    BoxHit res = AABB(p, extend, ray);\n    return res;\n}\n\n\nfloat transmittance(float dist){\n    // ref video https://youtu.be/Qj_tK_mdRcA\n    \n    // bad approximation of \"beers law\"? (macro for absorption)\n    float trans = exp(-dist*CLOUD_DENSITY);\n    \n    trans = clamp(trans, 0.0, 1.0);\n    // this is meant as a transmittance: 1.0 means we see through the cloud and 0.0 means we don't.\n    return trans;\n}\n\n\n\nvec3 terrain_palette(float h){\n    // return a specific color based on height. \n    // I manaually draw the RGB curves in a curve editor tool I have for thermal imaging\n    // then crafted functions in graphtoy to minic their paths and put it here\n    \n    // offsets\n    float h_r = h - 0.52;\n    float h_g = h - 0.4;\n    float h_b = h - 0.15;\n    // cubic polynomials\n    float r = (6.0*pow(h_r,3.0) + 0.1*pow(h_r,2.0) + 0.0*h_r +0.3);\n    float g = (6.0*pow(h_g,3.0) + 0.1*pow(h_g,2.0) + -1.0*h_g +0.3);\n    float b = (4.0*pow(h_b,3.0) + 0.1*pow(h_b,2.0) + -2.0*h_b +0.3);\n    \n    //vec3(0.267, 0.133, 0.001); // ~#442200\n    vec3 col = vec3(r,g,b);\n    col = clamp(col, vec3(0.0), vec3(1.0)); // ensure no negative or overbright colors!\n    return col;\n}\n\nvec4 sampleHeight(ivec2 cell){\n    // to allow for more complex math to determine height\n    // .rgb should just return the texture color or some modification of it\n    //cell.x = (cell.x + iFrame) % int(iChannelResolution[0].x); // fun texture scroll\n    vec4 tex = texelFetch(iChannel0, cell, 0);\n    vec4 res;\n    res.a = tex.r; // our height data is in this channel\n    res.rgb = terrain_palette(res.a*1.5-0.2); // move it a round a bit so the pallete looks okay...\n    \n    // could also just be a constant here!\n    if (tex.b > 0.0){\n        // cheap solid water in amount of water per pillar...\n        // TODO semi transparen/reflective water?\n        // the simulation is in the Buffer pass, we just reconstruct the height for rendering here\n        res.a += tex.b;\n        res.rgb = mix(vec3(0.2, 0.5, 0.8), vec3(0.1, 0.1, 0.9), tex.b*20.0); // little color for water \"depth\"\n    }\n    res.a *= HEIGHT_SCALE;\n    return res;\n}\n// this could be joined into the function above.\nfloat sampleClouds(ivec2 cell){\n    // idea is to read the texture data in a specific channel for cloud height/density?\n    // this needs to be implemented in my function down below as an alternative hit.\n    vec4 tex = texelFetch(iChannel0, cell, 0);        \n    float res = tex.g; // this channel has \"cloud\" terrain\n    // maybe we clamp it or something to have no clouds?\n    res -= 0.55; // negative values become clouds that show up.\n    return res;    \n}\n\nvec4 raycast(Ray ray, inout vec2 clouds){\n    // cast the ray untill there is a hit or we exit the box\n    // \"any hit\" shader?\n    // returns tex + dist, negative dist means a \"miss\"\n    // the inout for clouds sums up it's distance and depth of clouds.\n    BoxHit box = AABB(vec3(0.0, 0.0, HEIGHT_SCALE*0.5), vec3(1.0, 1.0, HEIGHT_SCALE*0.5), ray);\n    clouds = vec2(0.0, 0.0);\n    \n    vec3 entry = box.entry;\n    \n    if (!box.hit){\n        // if we \"MISS\" the whole box (not inside?).\n        \n        return vec4(vec3(0.2, 0.8, 0.0), -abs(box.exit_dist));\n    }\n    // everything below here is inside the box\n    if (box.inside){       \n        // if we are \"inside\" the entry should just be ro!\n        entry = ray.origin; // maybe problems with distance caluclations at the end?\n    }\n    \n    //return vec4(vec3(0.6), 1.0);\n    \n    //return entry.rgbb;\n    \n    ivec2 current_cell = worldToCell(entry); // TODO: this one is problematic!\n    int i;\n    ivec2 max_cells = CELLS - min(current_cell, CELLS-current_cell);\n    int max_depth = (max_cells.x + max_cells.y)+2; // could also be min!\n    for (i = 0; i < max_depth; i++){        \n        if (current_cell.x < 0 || current_cell.x >= CELLS.x ||\n            current_cell.y < 0 || current_cell.y >= CELLS.y){\n            // we marched far enough are are \"outside the box\" now!\n            return vec4(vec3(0.4), -abs(box.exit_dist));\n        }        \n        // so let's look for clouds first!\n        float cloud_depth = sampleClouds(current_cell);        \n        if (cloud_depth < 0.){ // cand adjust how \"many\" clouds here!\n            // only if there is a cloud we even consider this\n            BoxHit cloud = pillar_hits(current_cell, (cloud_depth*0.2), ray);\n            if (cloud.hit){                \n                // for transmittance we accumulate the distance\n                clouds.x += (distance(cloud.entry,cloud.exit)); // +(cloud_depth*0.001)); // add some random variation?\n                \n                // the \"color\" of clouds is based on the depth, scaled by the already accumulated transmittance\n                // sorta the distance to the sun, exit because entry can be at the top\n                // and how much of an angle the sun was at...\n                // the idea is to sum up how much \"light\" this has accumulated.\n                float hit_depth = (HEIGHT_SCALE-cloud.exit.z);\n                float sun_angle = clamp(dot(SUN, vec3(0.0,0.0,1.0)), 0.0, 1.0);\n                clouds.y += abs(cloud_depth*transmittance(clouds.x)*sun_angle*transmittance(hit_depth));\n                \n                // TODO use cloud.inside to increase the scale? (try to remove the moire pattern)\n                //return vec4(vec3((1.0 - cloud_depth)), 0.0*abs(cloud_hit.x));\n            }\n        }\n        \n        vec4 tex = sampleHeight(current_cell);\n        BoxHit pillar = pillar_hits(current_cell, tex.a, ray);\n        \n        if (pillar.hit) {\n            // \"any hit\" (side/top/bot) -> loop ends here            \n            // do a little bit of light sim by doing diffuse \"block of chalk\"\n            vec3 col = tex.rgb;\n            // half the phong diffuse\n            // TODO: assume some base \"emissive\" quality to all pillars (or scaled with some value?)\n            // needs better hit model and shader to accumulate over a few traces.\n            // TODO: should one of them be negative?\n            col *= (2.0*dot(pillar.entry_norm, SUN)) + 0.2; // \"ambient\"/emission term\n            \n            return vec4(col, abs(pillar.entry_dist));\n        }\n        \n        \n        if (pillar.exit_dist >= box.exit_dist){\n            return vec4(vec3(0.8), -abs(pillar.exit_dist));\n        }\n        \n        // the step\n        ivec2 next_cell = current_cell + ivec2(pillar.exit_norm.xy);\n        if (next_cell == current_cell){\n            // in this case we do another raycast - but without any Z component\n            // so the vector is sideways and points to a new cell!\n            vec3 flat_rd = vec3(ray.dir.xy, 0.0);\n            Ray flat_ray = Ray(ray.origin, flat_rd, 1.0/flat_rd);\n            \n            BoxHit grid = pillar_hits(current_cell, 1.0, flat_ray);\n            next_cell += ivec2(grid.exit_norm.xy); // TODO check if this norm is correct!\n        }\n        // for next iteration\n        current_cell = next_cell;\n    }\n    //return vec4(vec2(current_cell)/vec2(CELLS), 0.0, 0.0);\n    // defualt \"miss\"? -> like we exit the box?\n    \n    return vec4(vec3(1,0,0), -abs(box.exit_dist));\n\n}\n\n// more like a bad shadowmap\nfloat shadow(Ray sun_ray){\n    // return the amount of shadowed?\n    // we are now marching upwards from some hit\n    // ro is essentially the point we started from\n    // rd is the sun angle\n    vec2 cloud_values;\n    vec4 res = raycast(sun_ray, cloud_values);\n    //return res.a;\n    if (res.a < 0.0){// || (ro + rd*res.a).z >= HEIGHT_SCALE){\n        // likely means outside the box/ground!\n        // so think like \"skylight\"        \n        float cloud_transmittance = transmittance(cloud_values.x);\n        // full sunlight        \n        return cloud_transmittance;\n    }    \n    else {\n        return 0.0;\n    }\n}\n\nfloat checkerboard(vec2 check_uv, float cells){\n    check_uv *= cells/2.0;\n    float rows = float(mod(check_uv.y, 1.0) <= 0.5);\n    float cols = float(mod(check_uv.x, 1.0) <= 0.5);\n    return float(rows == cols);\n}\n\n\nvec4 sampleGround(vec3 ro, vec3 rd){\n    // for any ray that misses the heightmap\n    // TODO: rename to sample skybox maybe? as the ground is sorta part of that...\n    float ground_height = 0.0;\n    float ground_dist = (ground_height-ro.z)/rd.z;\n    if (ground_dist < 0.0) {\n        // essentially sky hit instead?\n        // just some random skybox right now... could be improved of course!\n        vec3 col = vec3(0.23, 0.59, 0.92)*exp(dot(SUN, rd)-0.8);\n        col = clamp(col, vec3(0.0), vec3(1.0));\n        return vec4(col, 30.0); // some random distance that is positive!\n    }\n    \n    vec3 ground_hit = ro + (rd * ground_dist);\n        \n    float val = checkerboard(ground_hit.xy, 8.0)* 0.1;\n    val += 0.45;\n    //val *= 2.0 - length(abs(ground_hit));\n    \n    // fake sun angle spotlight... TODO actual angle and normal calculation!\n    val *= 2.5 - min(2.3, length((-SUN-ground_hit)));//,vec3(0.0,0.0,1.0));\n    \n    vec3 col = vec3(val);\n    return vec4(col, ground_dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv normalized to [-1..1] for height with more width\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mo = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    //fragColor = texture(iChannel0, uv);\n    //return;\n    \n    // for when it's just idling...   \n    float azimuth = iTime*0.1 + mo.x; // keeps a bit of residue of the mouse!\n    float altitude = 0.7+cos(iTime*0.25)*0.35;      \n    if (sign(iMouse.z) > 0.0){\n        // orbiting camera setup\n        azimuth = PI*mo.x;\n        altitude = 0.5*PI*clamp(mo.y+1.0, -0.01, 0.99); // maybe just positive?\n    }\n    \n    // make sure you don't look \"below\"\n    altitude = clamp(altitude, HEIGHT_SCALE*0.5, PI);\n    \n    // a unit length orbit!\n    vec3 camera_pos = vec3(\n        cos(azimuth)*cos(altitude),\n        sin(azimuth)*cos(altitude),\n        sin(altitude));               \n    // the camera is always looking \"at\" the origin or half way above it\n    vec3 look_dir = normalize(vec3(0.0, 0.0, HEIGHT_SCALE*0.5) - camera_pos);\n    \n    \n    // TODO moving the camera in and out over time??\n    camera_pos += look_dir * -0.1; // moving the camera \"back\" to avoid occlusions?\n    // two vectors orthogonal to this camera direction (tagents?)    \n    //vec3 look_u = camera_pos + vec3(-sin(azimuth), cos(azimuth), 0.0);\n    //vec3 look_v = camera_pos + vec3(sin(altitude)*-cos(azimuth), sin(altitude)*-sin(azimuth), cos(altitude));    \n\n    \n    // turns out analytically these aren't correct. so using cross instead -.-\n    vec3 look_u = normalize(cross(vec3(0.0, 0.0, -1.0), look_dir));\n    vec3 look_v = normalize(cross(camera_pos, look_u)); // is this faster?\n    // camera plane(origin of each pixel) -> barycentric?\n    \n    vec3 camera_plane;\n    vec3 ray_dir;\n    vec3 ray_origin;\n                        \n    if (FOV > 0.0){\n        // assume a pinhole camera.\n        // FOV is the horizontal fov, the given focal length becomes:\n        // the 1.0 is the sensor height.\n        float focal_length = 1.0/tan(radians(FOV*0.5));\n        \n        // the ro\n        camera_plane = camera_pos - (look_dir*focal_length) + ((look_u*uv.x) + (look_v*uv.y))*-1.0; // inverted here to see upright\n        ray_origin = camera_pos;\n        \n        // the rd\n        ray_dir = camera_pos-camera_plane;\n        ray_dir = normalize(ray_dir);        \n    }\n    \n    else {\n        // negative FOV values are interpreted as a sensor size for a orthographic camera!\n        // horizontal sensor size, -1 would be something sensible... everything else is far away\n        float sensor_size = FOV*0.5*-1.0;\n        camera_plane = camera_pos + ((look_u*uv.x)+(look_v*uv.y))*sensor_size; // wider fov = larger \"sensor\"\n        ray_dir = look_dir;\n        ray_origin = camera_plane;\n    }\n    \n    Ray camera = Ray(ray_origin, ray_dir, 1.0/ray_dir);\n    \n    // actual stuff happening:\n    vec2 cloud_val;\n    vec4 res = raycast(camera, cloud_val);\n    // fragColor = vec4(vec3(res.rgb),1.0);\n    //return; // early debug exit\n    if (res.a < 0.0) {\n        // we missed the initial terrain\n        res = sampleGround(ray_origin, ray_dir);\n        \n        // TODO: the skybox hit returns a negative distance, so we need to handle that\n        //res.a = abs(res.a);\n    }\n    vec3 hit = ray_origin + (ray_dir*res.a);\n\n    // TODO: offset the ro a bit?\n    Ray sun_check = Ray(hit+0.001*SUN, SUN, 1.0/SUN);\n    \n    vec2 cloud_foo; // unused?\n    vec4 ref = raycast(sun_check, cloud_foo).rgba; //reflection (the full shadow)    \n    ref.rgb *= 1.0 - step(0.0, ref.a); // this makes misses black?\n    // ref.rgb *= 1.0-exp(-shadow_cloud*15.0); // more \"realistic\" cloud shadow?\n    \n    float shadow_amt = shadow(sun_check);\n    // actually more light amount -.-\n    // so we add and \"ambient\" base like here\n    vec3 col = res.rgb * max(0.3, shadow_amt);\n\n    float cloud_trans = transmittance(cloud_val.x);\n    vec3 cloud_col = vec3(1.0 - cloud_val.y*0.25); // *(1.0-cloud_trans); // no more alphapremultiplication...\n    col = mix(col, cloud_col, 1.0-cloud_trans);\n    \n    // TODO: better \"shadow\" value via actually colored shadow??\n    // vec3 col2 = res.rgb + ref.rgb*0.3;    \n    // col = vec3(uv.x > 0.0 ? col.rgb : col2.rgb);\n    \n    fragColor = vec4(vec3(col),1.0);\n}",
      "name": "Image",
      "description": "",
      "type": "image"
    },
    {
      "inputs": [
        {
          "id": 33,
          "src": "/presets/tex00.jpg",
          "ctype": "keyboard",
          "channel": 1,
          "sampler": {
            "filter": "linear",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        },
        {
          "id": 257,
          "src": "/media/previz/buffer00.png",
          "ctype": "buffer",
          "channel": 0,
          "sampler": {
            "filter": "linear",
            "wrap": "clamp",
            "vflip": "true",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": 257,
          "channel": 0
        }
      ],
      "code": "// for the terrain map I combined a bunch of existing and tutorial level snippets\n\n// water simulation controls:\n// SPACE - toggle all simulaion on/off :: default:on\n// E - Erosion simulation toggle on/off :: default:off\n// R - Rain for low clouds toggle on/off :: defualt:on\n\n\n// from https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// wraps the bitconversion and just accessses half the values\nfloat hash21(in vec2 a){\n    uvec2 b = uvec2(floatBitsToUint(a.x), floatBitsToUint(a.y));\n    uvec2 c = pcg2d(b);\n    float r = float(c.x)/float(uint(-1)); // seems to work I guess... but don't we lose a lot of data??\n    // fract(uintBitsToFloat(c.x)) // this one causes issues due to NaN or something, results in black spots in the noise\n    return r;\n}\n\n// TODO to make the clouds more accurate, this should actually be a slice of 3D noise we rotate through\nfloat noise(in vec2 a){\n   // perlin 2D noise\n   vec2 i = floor(a);\n   vec2 f = fract(a);\n   \n   // four corners\n   float bl = hash21(i + vec2(0.0, 0.0));\n   float br = hash21(i + vec2(1.0, 0.0));\n   float tl = hash21(i + vec2(0.0, 1.0));\n   float tr = hash21(i + vec2(1.0, 1.0));\n   \n   vec2 s = smoothstep(0.0, 1.0, f);\n   \n   \n   return mix( mix(bl, br, s.x),\n               mix(tl, tr, s.x), s.y);\n}\n\n// via https://thebookofshaders.com/13/\nfloat fbm(in vec2 p){\n    \n    // parameters\n    int octaves = 8;\n    float l = 2.0;\n    float g = 0.5;\n    \n    // initial values\n    float a = 0.5;\n    float f = 1.0;\n    float res = 0.0;\n    for(int i = 0; i < octaves; i++){\n        res += a * noise(p*f);\n        f *= l;\n        a *= g;\n        \n    }\n    return res;\n    \n}\n\nvec4 init_terrain(vec2 uv, float time_seed){\n    // initialize the terrain?\n\n    vec4 start;\n    // we don't do anything interesting here :(\n    float height = fbm(uv*3.0+vec2(time_seed*0.2));    \n    // let's have some fun!\n    float clouds = fbm(uv*4.0+vec2(-time_seed*0.1));\n    \n    // water as an amount, not a height.\n    float water = max(0.0, 0.3-height);\n\n    // alpha channel currently not used...\n    start = vec4(vec3(height, clouds, water),1.0);\n    return start;\n}\n\n// idea... look at the the neighbords and then check if water exists in the highest point.\n// step the water down (by full amount) or based on the gradient?\nvec2 simulate_water(ivec2 pos){\n    // do we get the clouds to know where it rains?\n    vec4 old = texelFetch(iChannel0, pos, 0); // these could be passed in?                \n    float old_water = old.z;  \n    float old_height = old.x;\n    \n    float evaporation = iTimeDelta*(max(0.0,((3.5*old_height)-0.3)));        \n    old_water *= (1.0-evaporation);\n    \n    \n    float water_level = old_height + old_water;\n    float water_change = 0.0; // the amount \"added\" or removed\n    float height_change = 0.0; \n    \n    // rain, toggle with R\n    float rain_toggle = 1.0 - texelFetch(iChannel1, ivec2(82, 2), 0).x;   \n    if (old.y < 0.2) {\n        // could be based on cloud thickness, maybe even drain the clouds?\n        water_change += iTimeDelta*0.1*rain_toggle;\n    }   \n    \n    // REDO with a loop\n    ivec2 neighbors[4] = ivec2[4] (ivec2(1,0), ivec2(-1,0), ivec2(0,1), ivec2(0,-1));\n    int i;\n    for (i=0; i<neighbors.length(); i++){        \n        vec4 n = texelFetch(iChannel0, pos+neighbors[i], 0);\n        float n_level = n.x + n.z;\n        float water_diff = n_level - water_level;        \n        water_change += clamp(water_diff, -old_water, n.z);\n    }\n    \n    water_change /= float(neighbors.length()); // does this need to be normalized?\n    \n    \n    // erosion demo: toggle with E\n    float erotion_toggle = texelFetch(iChannel1, ivec2(69, 2), 0).x;   \n    height_change = -water_change*0.2*erotion_toggle; // erosion like this?\n    \n    \n    return vec2(old_height + height_change, old_water + water_change);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    ivec2 st = ivec2(fragCoord);\n    \n    if (fragCoord.x > iResolution.y || fragCoord.x > 512.0 || fragCoord.y > 512.0){\n        // will break on protrait aspect ratio -.-\n        discard; // throw away the threads that are outside the simulation area\n    }\n        \n    //TODO terrain can still move if we offset the sample coords!\n    vec4 prev = texelFetch(iChannel0, st, 0);\n    if (iFrame < 1 || prev.x <= 0.0){ // hack for resizing? -> still messes up uv scaling...\n        prev = init_terrain(uv, 0.0); // TODO: change the value here to something like iDime.w to et different starting terrains.\n    }\n    else {\n        // let's have some fun!\n        float clouds = fbm(uv*4.0+vec2(-iTime*0.3));\n                \n        prev.y = clouds;\n        // press spacebar to toggle water sim (rain, gravity and evaporation) on/off... stars on on.\n        if (texelFetch(iChannel1, ivec2(32, 2), 0).x<0.5){\n            prev.xz = simulate_water(st);\n        }\n    }\n    \n    \n    \n    // clouds = uv.y; //ramp for testing\n    // the blue channel might be water... (and we could animate/simulate it here!)\n    //fragColor = vec4(vec3(height, clouds, water),1.0);\n    \n    fragColor = prev;\n}",
      "name": "Buffer A",
      "description": "",
      "type": "buffer"
    }
  ]
}